-*- org -*-

* [1/9] Protocol
** DONE Format: The basics
   CLOSED: [2024-01-04 Thu 10:43]
   + Server starts when client connect, sends `OK rong <VERSION> <SOCKET>`
   + All server responses is single line, starting with 'OK' or 'ERR'
** TODO Command: `load`
** TODO Format: Multi-line server response? (for interactive `help` command)
   I want the server to be able to talk to a user for exploratory purposes.
   Thus there should always be REPL-mode, and it should have a `help` command.
   For this to work server needs to be able to respond with multi-line output,
   what should this look like? (How do other protocols do this?)

   The help output is this mode should preferably be the same as with command
   line help, e.g. `rong help load` should show the same text as `help load` in
   REPL-mode.
** TODO Format: Raw mode? (for visual editor clients)
   Telnet protocol apparently have a line-based and a raw mode. How does that
   work?
** TODO Selection commands
** TODO Cursor move commands
** TODO Text insertion
** TODO Text deletion
** TODO Server pushes (client should be able to subscribe to events)
   This needs to be specified on a file level. Also, a client that isn't
   displaying a certain file should be able to unsubscribe, then resubscribe
   and ask for updates when a user starts editing that file again.
* [11/22] Server
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :END:
** DONE Listen to multiple incoming connections (without threading)
   CLOSED: [2023-12-31 Sun 15:49]
   This is done using IO::Select, and the code was adapted from final example
   code on the IO::Select manpage.
** [6/6] Daemonize server completely
   From: https://theworld.com/~swmcd/steven/tech/daemon.html
   (Though I added wait() to reap the intermediate process.)

        use POSIX 'setsid';
        sub daemonize {
            fork and do { wait; return };
            POSIX::setsid();
            fork and exit;
            umask 0;
            chdir '/';
            close STDIN;
            close STDOUT;
            close STDERR;
        }
 
*** DONE 1. Fork intermediate process
    CLOSED: [2024-01-01 Mon 09:13]
    `fork` -- The first fork allows the child to run the daemon while the
    parent continues execution, or exits. In addition, it ensures that the
    child is not a process group leader, so that the following `setsid()` call
    will succeed.

    I also added a `wait` call in the invoking client process, so as to reap
    the intermediate process and never leave a zombie process in the process
    table.
*** DONE 2. Create new process session
    CLOSED: [2024-01-01 Mon 09:13]
    `setsid` -- This is how we lose our controlling terminal. `setsid` makes
    our process the session leader of a new session, and when a new session is
    created, the session leader has no controlling terminal.
*** DONE 3. Fork server process
    CLOSED: [2024-01-01 Mon 09:13]
    `fork` -- The leader of a new session has no controlling terminal, but
    it could acquire one, for example, by opening `/dev/tty` or the like. To
    ensure that this doesn't happen, we fork again.

    After the second fork, the child is not the session leader (the parent is
    the session leader) and only a session leader can acquire a controlling
    terminal. Of course, the child could become a session leader by executing
    `setsid` again, but presumably anyone who does that knows what they are
    doing.
*** DONE 4. Reset umask
    CLOSED: [2024-01-01 Mon 09:13]
    `umask 0` -- `umask` is inherited across `fork` and `exec`, and we don't
    want our daemon to be limited by whatever `umask` it happens to inherit
    from its parent.
*** DONE 5. Change dir to '/'
    CLOSED: [2024-01-01 Mon 09:13]
    `chdir '/'` -- The current working directory is inherited across `fork` and
    `exec`. If we leave the daemon running in some random directory, then the
    file system that contains that directory can never be `umounted`, and
    someone might want to.
*** DONE 6. Close standard streams
    CLOSED: [2024-01-01 Mon 09:13]
    `close` -- Even though the daemon has no controlling terminal, it may still
    have open file descriptors on a terminal, and these can cause trouble. For
    reliable operation, close the system file descriptors.
** DONE Simple logging to tempdir
   CLOSED: [2024-01-01 Mon 11:02]
   Store a log as a buffer? Log to a file? Write status stuff into
   notifications? Have a client log mode, so that all error messages are sent
   to all log-receiving clients?
** DONE Git commit hook to validate $VERSION before commit
   CLOSED: [2024-01-01 Mon 15:55]
** DONE Redirect server STDERR to logfile
   CLOSED: [2024-01-04 Thu 09:42]
   So that error messages wind up there. (STDOUT is not important, since the
   logfile filehandle is selected and the output of print() and friends
   therefore already winds up in the logfile.)

   Took the approach exemplified by the following snippet in the perlipc(1)
   manpage (except that I'm closing STDIN rather than reading from /dev/null).

       sub daemonize {
           chdir("/")                     || die "can't chdir to /: $!";
           open(STDIN,  "<", "/dev/null") || die "can't read /dev/null: $!";
           open(STDOUT, ">", "/dev/null") || die "can't write /dev/null: $!";
           defined(my $pid = fork())      || die "can't fork: $!";
           exit if $pid;              # non-zero now means I am the parent
           (setsid() != -1)           || die "Can't start a new session: $!";
           open(STDERR, ">&", STDOUT) || die "can't dup stdout: $!";
       }
 
** DONE Server greeting
   CLOSED: [2024-01-04 Thu 10:43]
   Upon connecting the server should send a greeting containing server name and
   version number. E.g. `OK rong 0.0.10 /tmp/rong-1000/default`.
** [0/4] Simple subcommands
*** TODO `rong FILE`
*** TODO `rong cat`
*** TODO 'kill' -- to kill server
*** TODO 'start-server' start background daemon w/o client
    This starts the daemon process and then immediately exists without
    creating, starting a client. (Under normal circumstances this command is
    not needed since a server if it isn't already running, when starting a
    client.)

    Note: In the future we might want a way to name the server socket, so that
    user may run multiple daemons at the same time.
** TODO Keep track of client-specific data
   E.g. login info, maybe more later.
** TODO On startup make sure any already existing tempdir is chmod 0700
   Function: create_tempdir() -- Easiest is maybe to just 'chmod 0700' the
   directory if it exists on startup?
** TODO Accept standard signals for reload/restart (SIGHUP, SIGINT etc.)
   Resist SIGTERM! This is so that `pkill rong` kills client processes but not
   the server.

   From: https://docstore.mik.ua/orelly/perl/cookbook/ch16_01.htm

   SIGINT: is normally triggered by Ctrl-C. This requests that a process
     interrupt what it's doing. Simple programs like filters usually just die,
     but more important ones like shells, editors, or FTP programs usually use
     SIGINT to stop long-running operations so you can tell them to do something
     else.

   SIGQUIT: is also normally generated by a terminal, usually Ctrl-\. Its
     default behavior is to generate a core dump.

   SIGTERM: is sent by the kill shell command when no signal name is explicitly
     given. Think of it as a polite request for a process to die. SIGUSR1 and

   SIGUSR2: are never caused by system events, so user applications can safely
     use them for their own purposes.

   SIGPIPE: is sent by the kernel when your process tries to write to a pipe or
     socket when the process on the other end has closed its connection, usually
     because it no longer exists.

   SIGALRM: is sent when the timer set by the alarm function expires, as
     described in Recipe 16.21.

   SIGHUP: is sent to a process when its controlling terminal gets a hang-up
     (e.g., the modem lost its carrier), but it also often indicates that a
     program should restart or reread its configuration.

   SIGCHLD: is probably the most important signal when it comes to low-level
     systems programming. The system sends your process a SIGCHLD when one of
     its child processes stops running - or, more likely, when that child exits.
     See Recipe 16.19 for more on SIGCHLD.
** [0/4] FAR-FLUNG FUTURE FEATURES
*** TODO Use Perl -T (taint flag) for the server
    Manpage perlipc says this is a good idea:

    > You should use the `-T` flag to enable taint checking (see perlsec) even
    > if we aren't running setuid() or setgid(). This is always a good idea for
    > servers or any program run on behalf of someone else (like CGI scripts),
    > because it lessens the chances that people from the outside will be able
    > to compromise your system.
 
*** TODO Client authentication
    Is being able to connect to the socket enough of an authentication?
*** TODO Keep track of open connections, die when last has exited(?)
    But don't die before first client has connected.
*** TODO Client-server connection should agree on version
    Server should respond to the client with version, and the client should
    check that the version isn't too far off into the future. (I.e. only the
    patch number is allowed to be different from the client's version number.)

    Is there a way to restart the server if versions if needed? (That is, keep
    state, but reload the server's code?)
* [2/6] Client
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :END:
** DONE Read from both STDIN and server at same time
   CLOSED: [2023-12-31 Sun 15:49]
   This is done using IO::Select.
** DONE Verify server greeting when connecting
   CLOSED: [2024-01-05 Fri 00:30]
   When a client connects to the server it should verify the returned greeting
   using something like:

       # Verify server greeting.
       if ($sockets->can_read) {
           defined(my $greeting = <$server>)
               or die "Cannot read server greeting: $!\n";
          die "Cannot understand server greeting\n",
              "    expected: OK rong #.#.# $socket\n",
              "    but got : $greeting"
              unless $greeting =~ /^OK rong \d+\.\d+\.\d+ \Q$socket\E$/;
       }
 
** TODO Send single server commands
   The client should be able to connect, some specified command(s) then
   disconnect, rather than always going into an interactive REPL-mode.
** TODO Change directory to root
   Clients should remember their starting directory, but change dir to '/' so
   that their original dir can be unmounted etc.
** TODO Should shutdown() be used when closing socket?
   https://docstore.mik.ua/orelly/perl/cookbook/ch17_10.htm
** [0/1] FAR-FLUNG FUTURE FEATURES
*** TODO Verify server version when connecting
    When connecting the client should verify the server version relative to the
    client's version, only allowing the PATCH (and maybe the MINOR?) number to
    differ.

    Or, maybe we would reload the daemon, keeping all data but update the code?
    Would that be possible?
* [eof]
