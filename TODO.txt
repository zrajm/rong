-*- org -*-

* DONE Make client read from both STDIN and server at same time
  CLOSED: [2023-12-31 Sun 15:49]
  This is done using IO::Select.
* DONE Listen to multiple incoming connections (without threading)
  CLOSED: [2023-12-31 Sun 15:49]
  This is done using IO::Select, and the code was adapted from final example
  code on the IO::Select manpage.
* [6/6] Daemonize server completely
  CLOSED: [2024-01-01 Mon 09:13]
  From: https://theworld.com/~swmcd/steven/tech/daemon.html
  (Though I added wait() to reap the intermediate process.)

        use POSIX 'setsid';
        sub daemonize {
            fork and do { wait; return };
            POSIX::setsid();
            fork and exit;
            umask 0;
            chdir '/';
            close STDIN;
            close STDOUT;
            close STDERR;
        }
 
** DONE 1. Fork intermediate process
   `fork` -- The first fork allows the child to run the daemon while the parent
   continues execution, or exits. In addition, it ensures that the child is not
   a process group leader, so that the following `setsid()` call will succeed.

   I also added a `wait` call in the invoking client process, so as to reap the
   intermediate process and never leave a zombie process in the process table.
** DONE 2. Create new process session
   `setsid` -- This is how we lose our controlling terminal. `setsid` makes our
   process the session leader of a new session, and when a new session is
   created, the session leader has no controlling terminal.
** DONE 3. Fork server process
   `fork` -- The leader of a new session has no controlling terminal, but it
   could acquire one, for example, by opening `/dev/tty` or the like. To ensure
   that this doesn't happen, we fork again.

   After the second fork, the child is not the session leader (the parent is
   the session leader) and only a session leader can acquire a controlling
   terminal. Of course, the child could become a session leader by executing
   `setsid` again, but presumably anyone who does that knows what they are
   doing.
** DONE 4. Reset umask
   `umask 0` -- `umask` is inherited across `fork` and `exec`, and we don't
   want our daemon to be limited by whatever `umask` it happens to inherit from
   its parent.
** DONE 5. Change dir to '/'
   `chdir '/'` -- The current working directory is inherited across `fork` and
   `exec`. If we leave the daemon running in some random directory, then the
   file system that contains that directory can never be `umounted`, and
   someone might want to.
** DONE 6. Close standard streams
   `close` -- Even though the daemon has no controlling terminal, it may still
   have open file descriptors on a terminal, and these can cause trouble. For
   reliable operation, close the system file descriptors.
* DONE Simple server logging to tempdir
  CLOSED: [2024-01-01 Mon 11:02]
  Store a log as a buffer? Log to a file? Write status stuff into
  notifications? Have a client log mode, so that all error messages are sent to
  all log-receiving clients?
* DONE Git commit hook to validate $VERSION before commit
  CLOSED: [2024-01-01 Mon 15:55]
* DONE Redirect server STDERR to logfile
  CLOSED: [2024-01-04 Thu 09:42]
  So that error messages wind up there. (STDOUT is not important, since the
  logfile filehandle is selected and the output of print() and friends
  therefore already winds up in the logfile.)

  Took the approach exemplified by the following snippet in the perlipc(1)
  manpage (except that I'm closing STDIN rather than reading from /dev/null).

      sub daemonize {
          chdir("/")                     || die "can't chdir to /: $!";
          open(STDIN,  "<", "/dev/null") || die "can't read /dev/null: $!";
          open(STDOUT, ">", "/dev/null") || die "can't write /dev/null: $!";
          defined(my $pid = fork())      || die "can't fork: $!";
          exit if $pid;              # non-zero now means I am the parent
          (setsid() != -1)           || die "Can't start a new session: $!";
          open(STDERR, ">&", STDOUT) || die "can't dup stdout: $!";
      }
 
* DONE Client-server protocol basics
  CLOSED: [2024-01-04 Thu 10:43]
  + Server starts when client connect, sends `OK rong <VERSION> <SOCKET>`
  + All server responses is single line, starting with 'OK' or 'ERR'
* DONE Server greeting
  CLOSED: [2024-01-04 Thu 10:43]
  Upon connecting the server should send a greeting containing server name and
  version number. E.g. `OK rong 0.0.10 /tmp/rong-1000/default`.
* DONE Verify server greeting when connecting
  CLOSED: [2024-01-05 Fri 00:30]
   When a client connects to the server it should verify the returned greeting
   using something like:

       # Verify server greeting.
       if ($sockets->can_read) {
           defined(my $greeting = <$server>)
               or die "Cannot read server greeting: $!\n";
          die "Cannot understand server greeting\n",
              "    expected: OK rong #.#.# $socket\n",
              "    but got : $greeting"
              unless $greeting =~ /^OK rong \d+\.\d+\.\d+ \Q$socket\E$/;
       }
 
* DONE Make client be able to send single commands to server
  CLOSED: [2024-01-05 Fri 04:18]
  The client should be able to connect, some specified command(s) then
  disconnect, rather than always going into an interactive REPL-mode.
* [6/6] Basic subcommands
  Server commands only take zero or one arg. Client execute multi-arg commands
  as one command for each arg (resulting in one 'OK' or 'ERR' for each arg).
** DONE `rong load FILE...`
   CLOSED: [2024-01-05 Fri 15:21]
** DONE Escape filename when talking client<->server
   CLOSED: [2024-01-05 Fri 18:43]
** DONE `rong list`
   CLOSED: [2024-01-06 Sat 12:55]
** DONE `rong kill FILE...`
   CLOSED: [2024-01-08 Mon 15:01]
** DONE `rong help`
   CLOSED: [2024-01-10 Wed 00:55]
** DONE `rong save FILE`
   CLOSED: [2024-01-10 Wed 01:04]
** DONE `rong cat FILE`
   CLOSED: [2024-01-10 Wed 01:08]
* [13/13] `rong cd DIR` & relative filenames
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:
  All file-specific command accept both relative and absolute filenames. Output
  of 'list' command is relative to client's current dir (which is sent to
  server on connecting, as the server does all file name conversions).
** DONE Use File::Spec for filenames and path handling(?)
   CLOSED: [2024-01-10 Wed 19:52]
   File::Spec is a core module. Use that!
** [6/6] Use absolute paths internally
   CLOSED: [2024-01-10 Wed 19:52]
*** DONE Handle paths better
    The client cannot just always send full paths as args for each command (this
    would make REPL-mode unpleasant to use).

    How to do this? Deal with it on the client side? Or have client send it's
    current directory to the server as it is connecting?
*** DONE `load FILE`
*** DONE `list`
*** DONE `kill FILE`
*** DONE `save FILE`
*** DONE `cat FILE`
** DONE Connection specific options
   CLOSED: [2024-01-12 Fri 19:25]
   These are some config specific to a client-server connection. They are
   initialized when the client connects to the server, and forgotten again when
   a client disconnects. The only setting right now is the current directory of
   the client.

   In interactive mode the user is now able to `cd` somewhere, then have the
   `list` of files be relative to that current directory.
** WONT Better client session ID
   Not really needed, I think? `fileno()` should result in a unique number for
   each open file in the server, regardless of filename. The only benefit of
   using something more elaborate would be a lessened risk of accidentally
   sharing info with the next client to connect (which could happen if the
   previous connection failed to do its cleanup).

   Client session ID should be unique even across multiple sockets (for when we
   start doing that).
** [2/2] Client should always send `cd` command when connecting
   For single commands, issue a `cd $PWD` command before invoking the
   user-requested command(s).
*** DONE Always send initial `cd` from client
    CLOSED: [2024-01-14 Sun 00:03]
*** DONE Suppress output from initial `cd` command
    CLOSED: [2024-01-14 Sun 02:40]
** DONE Use `Cwd::getcwd()` instead of `Cwd:cwd()`
   CLOSED: [2024-01-16 Tue 18:34]
   `Cwd:cwd()` gives a weird error message when invoked from inside a
   non-existing directory:

      /bin/pwd: couldn't find directory entry in ‘..’ with matching i-node

   Also, using `Cwd::cwd()` does not resolve uniquely (since symlinks in the
   path are not resolved). So therefore, use `Cwd::getcwd()` (which does
   resolve all symlinks) instead.
** DONE Handle `~[username]` directories
   CLOSED: [2024-01-17 Wed 05:09]
* DONE `rong list` with no files loaded shouldn't display blank line
  CLOSED: [2024-01-17 Wed 03:26]
* DONE Fix `abspath()`
  CLOSED: [2024-01-17 Wed 05:09]
  Loading a file with a path like `foo/../lala` should result in the loaded
  file having a name which does not include the `..` component.
* DONE `rong list` when current dir is root -- use absolute paths
  CLOSED: [2024-01-17 Wed 05:23]
  When path is '/', display absolute paths.
* DONE Server should log when it starts
  CLOSED: [2024-01-17 Wed 21:33]
* DONE Server should log when it exits/dies
  CLOSED: [2024-01-17 Wed 21:33]
  An `END` block inside the Rong package, should work. But it doesn't fire on
  SIGINT (unless there's a trap, possibly?).

      END { warn "(server exited)\n" unless -t STDERR }
 
* DONE `create_tmpdir()` should use `File::Spec->tmpdir()`
  CLOSED: [2024-01-18 Thu 02:55]
* DONE Use `File::Spec->splitpath()` to get program name
  CLOSED: [2024-01-18 Thu 03:26]
* DONE Use `File::Spec->rootdir()`
  CLOSED: [2024-01-18 Thu 03:45]
* DONE Use `File::Spec` for all file name manipulations
  CLOSED: [2024-01-18 Thu 04:11]
* DONE Empty arg to `escape()` should return ""
  CLOSED: [2024-01-18 Thu 22:22]
* [1/11] Improve subcommands
** TODO Subcommand functions should not be in hash
** TODO `rong` (without args) should start server + list buffers
   This should start the daemon process and then immediately exist the client.
   (Under normal circumstances this command is not needed since a server if it
   isn't already running, when starting a client will start it.)

   Note: In the future we might want a way to name the server socket, so that
   user may run multiple daemons at the same time.
** TODO `rong repl`
   There should be a user greeting, with listing of commands also telling that
   ^C or ^D exists.
** TODO `rong cd` should allow symlink(s) in path
   When `foo` is symlink to `bar/baz` then cd `foo` should set the current dir
   to `foo` (NOT `bar/baz`)
** DONE `rong load` -- Give error in case of non-files & follow symlinks
   CLOSED: [2024-01-17 Wed 18:50]
   `abspath()` already resolved any symlinks in filename. Added errors for
   fifo, device files etc.
** TODO `rong load` -- Handle read errors
   Should any catch any errors gotten while reading (in `<$fh>` statement) too.
** TODO `rong save` -- Handle write errors
   Should any catch errors gotten while writing (in `print` statement) too.
** TODO `rong save` -- Make atomic
** TODO `rong cat` -- with no trailing newline
   If the file doesn't end in a newline, then newline should be added. This
   requires different schema for the OK/ERR message, as the OK/ERR no longer
   will be at the end of the last line. How do other protocols handle this?
** TODO `rong mv`
** TODO `rong cp`
* TODO Failing a command should result in non-zero exit status
* TODO Unicode text should work
  How should this be done? Clearly Perl needs to be aware that the loaded text
  is Unicode, but maybe the client-server communication needs to be in raw
  mode? See manpages for IO::Handle, IO::File, and IO::Socket.
** TODO Use sysread for sockets?
   See also: https://stackoverflow.com/a/5600853/351162 (diff <>, sysread, rect)
   Raw fileread: https://www.perlmonks.org/?node_id=1195588

   On nonblocking sockets and ->connected():
   https://www.ralph-schuster.eu/2015/06/19/nonblocking-sockets-and-perls-netdaemon/

   Webserver with Perl:
   https://redirect.cs.umbc.edu/courses/331/fall12/notes/perl/aWebserverWithPerl.html

   Switched to using recv() for the sockets, but it'd be nicer to use something
   that can be used on both STDIN and socket, to simplify the client REPL-loop.

   Sysread doesn't allow Unicode, but if set up so that just raw bytes are
   shuffled over the socket that shouldn't matter. (The benefit of this is to
   avoid hangs.)
* [0/8] Protocol
** TODO Format: Multi-line server response? (for interactive `help` command)
   I want the server to be able to talk to a user for exploratory purposes.
   Thus there should always be REPL-mode, and it should have a `help` command.
   For this to work server needs to be able to respond with multi-line output,
   what should this look like? (How do other protocols do this?)

   The help output is this mode should preferably be the same as with command
   line help, e.g. `rong help load` should show the same text as `help load` in
   REPL-mode.
** TODO Format: Raw mode? (for visual editor clients)
   Telnet protocol apparently have a line-based and a raw mode. How does that
   work?
** TODO Selection commands
** TODO Cursor move commands
** TODO Text insertion
** TODO Text deletion
** TODO Server pushes (client should be able to subscribe to events)
   This needs to be specified on a file level. Also, a client that isn't
   displaying a certain file should be able to unsubscribe, then resubscribe
   and ask for updates when a user starts editing that file again.
** TODO Separate protocol logic from server specifics
   The client and server skeleton logic should be in a separate module, and the
   specifics should be separated out into its own module.
* TODO File fingerprinting & checksumming
** TODO `rong load` -- Avoid useless reloads
   This should use fingerprinting, but do a checksum if fingerprint fails. That
   is, if file is identical to existing one, it should *never* be reloaded.
   (Instead a message should be given to the user.)
** TODO `rong save` -- Avoid useless resaves
   This should use fingerprinting, but do a checksum if fingerprint fails. That
   is, if file is identical to existing one, it should *never* be saved again.
   (Instead a message should be given to the user.)
* [2/6] Improve error messages & help
** DONE Fix faulty error messages (`__DIE__` hook double rewrite)
   CLOSED: [2024-01-18 Thu 22:17]
   Giving incorrect args to a command inserts 'rong:' twice in the error
   output. Fix this:

       $ rong list BLA
       rong list BLA: rong: No args allowed

   Was the result of a `$SIG{__DIE__}` hook being invoked inside an `eval { }`
   block.
** DONE Better sigdie handling
   CLOSED: [2024-01-19 Fri 19:46]
   Instead of having to `local $SIG{__DIE__} = 'DEFAULT'` inside of each eval
   block, the sigdie handler should detect that it was called from inside an
   eval, and not do it's usual error message rewriting.

   It was surprisingly hard to find a good description of how to avoid this,
   but I finally found it, hidden away in the perlfunc manpage (under the
   description of `die` function). Rather than giving a full code example, the
   manpage simply states that one should add the line `die @_ if $^S;` as the
   first line of any `$SIG{__DIE__}` handler.

   While searching for a way to do this I found the special Perl variable
   `$^S`, but had a hard time finding any more info since special characters
   aren't very googlable. I did find the following pages helpful though:

     + [[https://www.perlmonks.org/?node_id=51097][Perl's Warn and Die Signals (on Perlmonks)]]
     + [[https://www.perlmonks.org/?node_id=42411][SIGDIE (on Perlmonks)]]
     + perlfunc manpage (at end of description for `die`)
     + perlvar manpage (both under `%SIG` and `$^S`)
 
** TODO Sigdie handling should be setup at beginning of main
** TODO Make error messages more user friendly
  When invoking command from the command line, like so

      $ rong list osuh
      rong list osuh: No args allowed

  The error message should more similar to when an incorrect option was given:

      $ rong --osuhou
      rong: Unrecognized option '--osuhou'
      Try 'rong help' for more information.

  Something more like this:

      $ rong list osuh
      rong list "osuh": No args allowed
      Try 'rong help list' for more information.
 
** TODO Fetch help info from server
   The command information should be read from the server, so that the REPL
   will show the same help info as the command line client.
** TODO Option `--help` and command `help` give same output
* TODO Accept standard server signals (SIGHUP, SIGINT etc)
  Resist SIGTERM! This is so that `pkill rong` kills client processes but not
  the server.

  From: https://docstore.mik.ua/orelly/perl/cookbook/ch16_01.htm

  SIGINT: is normally triggered by Ctrl-C. This requests that a process
    interrupt what it's doing. Simple programs like filters usually just die,
    but more important ones like shells, editors, or FTP programs usually use
    SIGINT to stop long-running operations so you can tell them to do something
    else.

  SIGQUIT: is also normally generated by a terminal, usually Ctrl-\. Its
    default behavior is to generate a core dump.

  SIGTERM: is sent by the kill shell command when no signal name is explicitly
    given. Think of it as a polite request for a process to die. SIGUSR1 and

  SIGUSR2: are never caused by system events, so user applications can safely
    use them for their own purposes.

  SIGPIPE: is sent by the kernel when your process tries to write to a pipe or
    socket when the process on the other end has closed its connection, usually
    because it no longer exists.

  SIGALRM: is sent when the timer set by the alarm function expires, as
    described in Recipe 16.21.

  SIGHUP: is sent to a process when its controlling terminal gets a hang-up
    (e.g., the modem lost its carrier), but it also often indicates that a
    program should restart or reread its configuration.

  SIGCHLD: is probably the most important signal when it comes to low-level
    systems programming. The system sends your process a SIGCHLD when one of
    its child processes stops running - or, more likely, when that child exits.
    See Recipe 16.19 for more on SIGCHLD.
* TODO `rong list` option to display absolute paths
* TODO All clients should die (immediately) if server dies
  Maybe temporarily add a die command to test this on the server side?

  If not doing `chomp($x)` after reading STDIN in REPL-mode, and calling
  `deserialize()` before the `eval { }` in `invoke()` the first command in
  REPL-mode will work, but the second will crash the server.

  Is using $fh->connected to verify that we're still connected the way to do
  it?
* TODO Make sure error message is intelligible if initial `cd` fails
  This will happen if the current directory doesn't exist when starting rong.
* TODO Command to check if server is running (without starting it)
* TODO Escaping should use same schema as shell or 'ls' command
  To make it make when using `rong list`.
* [0/8] FAR-FLUNG FUTURE FEATURES
** TODO If socket file is deleted, should server re-create it(?)
** TODO Use `shutdown()` to close socket?
   https://docstore.mik.ua/orelly/perl/cookbook/ch17_10.htm
** TODO On startup make sure any existing tempdir is chmod 0700
   Function: create_tempdir() -- Easiest is maybe to just 'chmod 0700' the
   directory if it exists on startup?
** TODO Use Perl -T (taint flag) for the server
    Manpage perlipc says this is a good idea:

    > You should use the `-T` flag to enable taint checking (see perlsec) even
    > if we aren't running setuid() or setgid(). This is always a good idea for
    > servers or any program run on behalf of someone else (like CGI scripts),
    > because it lessens the chances that people from the outside will be able
    > to compromise your system.
 
** TODO Client authentication
   Is being able to connect to the socket enough of an authentication?
** TODO Keep track of open connections, die when last has exited(?)
   But don't die before first client has connected.
** TODO Change client directory to root
   Clients should remember their starting directory, but change dir to '/' so
   that their original dir can be unmounted etc.
** TODO Make client server-version agnostic
   The client needs a list of available commands from the server in order to
   parse the command line. To decouple the client and server completely, the
   client should ask the server for the available commands and use this info to
   parse the command line.

   There's gonna be a variable number of arguments for different server
   commands. Some will only ever take one arg ('load', 'save' etc.) some zero
   or one ('cd'), some two ('mv', 'cp' -- moar?).

   Maybe the server greeting could contain the relevant help info? For example
   something like (sadly, this would make the greeting longer that one line):

       OK rong 0.0.42 /tmp/rong-100/default 0(exit halt help list cd) 1(cd
           cat kill load save) 2(mv cp)
 
* [0/1] TESTS
** TODO Resolving absolute paths
   Then resolving any `/../` parts of a path, there's a corner case involving
   symlinks that needs to be considered. Here a description from the manpage
   File::Spec(3perl)

       Note that this does *not* collapse `x/../y` sections into `y`. This is
       by design. If `/foo` on your system is a symlink to `/bar/baz`, then
       `/foo/../quux` is actually `/bar/quux`, not `/quux` as a naive
       `../`-removal would give you. If you want to do this kind of processing,
       you probably want "Cwd"'s "realpath()" function to actually traverse the
       filesystem cleaning up paths like this.
 
* [eof]
