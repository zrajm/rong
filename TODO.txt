-*- org -*-

* DONE Make client read from both STDIN and server at same time
  CLOSED: [2023-12-31 Sun 15:49]
  This is done using IO::Select.
* DONE Listen to multiple incoming connections (without threading)
  CLOSED: [2023-12-31 Sun 15:49]
  This is done using IO::Select, and the code was adapted from final example
  code on the IO::Select manpage.
* [6/6] Daemonize server completely
  CLOSED: [2024-01-01 Mon 09:13]
  From: https://theworld.com/~swmcd/steven/tech/daemon.html
  (Though I added wait() to reap the intermediate process.)

        use POSIX 'setsid';
        sub daemonize {
            fork and do { wait; return };
            POSIX::setsid();
            fork and exit;
            umask 0;
            chdir '/';
            close STDIN;
            close STDOUT;
            close STDERR;
        }
 
** DONE 1. Fork intermediate process
   `fork` -- The first fork allows the child to run the daemon while the parent
   continues execution, or exits. In addition, it ensures that the child is not
   a process group leader, so that the following `setsid()` call will succeed.

   I also added a `wait` call in the invoking client process, so as to reap the
   intermediate process and never leave a zombie process in the process table.
** DONE 2. Create new process session
   `setsid` -- This is how we lose our controlling terminal. `setsid` makes our
   process the session leader of a new session, and when a new session is
   created, the session leader has no controlling terminal.
** DONE 3. Fork server process
   `fork` -- The leader of a new session has no controlling terminal, but it
   could acquire one, for example, by opening `/dev/tty` or the like. To ensure
   that this doesn't happen, we fork again.

   After the second fork, the child is not the session leader (the parent is
   the session leader) and only a session leader can acquire a controlling
   terminal. Of course, the child could become a session leader by executing
   `setsid` again, but presumably anyone who does that knows what they are
   doing.
** DONE 4. Reset umask
   `umask 0` -- `umask` is inherited across `fork` and `exec`, and we don't
   want our daemon to be limited by whatever `umask` it happens to inherit from
   its parent.
** DONE 5. Change dir to '/'
   `chdir '/'` -- The current working directory is inherited across `fork` and
   `exec`. If we leave the daemon running in some random directory, then the
   file system that contains that directory can never be `umounted`, and
   someone might want to.
** DONE 6. Close standard streams
   `close` -- Even though the daemon has no controlling terminal, it may still
   have open file descriptors on a terminal, and these can cause trouble. For
   reliable operation, close the system file descriptors.
* DONE Simple server logging to tempdir
  CLOSED: [2024-01-01 Mon 11:02]
  Store a log as a buffer? Log to a file? Write status stuff into
  notifications? Have a client log mode, so that all error messages are sent to
  all log-receiving clients?
* DONE Git commit hook to validate $VERSION before commit
  CLOSED: [2024-01-01 Mon 15:55]
* DONE Redirect server STDERR to logfile
  CLOSED: [2024-01-04 Thu 09:42]
  So that error messages wind up there. (STDOUT is not important, since the
  logfile filehandle is selected and the output of print() and friends
  therefore already winds up in the logfile.)

  Took the approach exemplified by the following snippet in the perlipc(1)
  manpage (except that I'm closing STDIN rather than reading from /dev/null).

      sub daemonize {
          chdir("/")                     || die "can't chdir to /: $!";
          open(STDIN,  "<", "/dev/null") || die "can't read /dev/null: $!";
          open(STDOUT, ">", "/dev/null") || die "can't write /dev/null: $!";
          defined(my $pid = fork())      || die "can't fork: $!";
          exit if $pid;              # non-zero now means I am the parent
          (setsid() != -1)           || die "Can't start a new session: $!";
          open(STDERR, ">&", STDOUT) || die "can't dup stdout: $!";
      }
 
* DONE Client-server protocol basics
  CLOSED: [2024-01-04 Thu 10:43]
  + Server starts when client connect, sends `OK rong <VERSION> <SOCKET>`
  + All server responses is single line, starting with 'OK' or 'ERR'
* DONE Server greeting
  CLOSED: [2024-01-04 Thu 10:43]
  Upon connecting the server should send a greeting containing server name and
  version number. E.g. `OK rong 0.0.10 /tmp/rong-1000/default`.
* DONE Verify server greeting when connecting
  CLOSED: [2024-01-05 Fri 00:30]
   When a client connects to the server it should verify the returned greeting
   using something like:

       # Verify server greeting.
       if ($sockets->can_read) {
           defined(my $greeting = <$server>)
               or die "Cannot read server greeting: $!\n";
          die "Cannot understand server greeting\n",
              "    expected: OK rong #.#.# $socket\n",
              "    but got : $greeting"
              unless $greeting =~ /^OK rong \d+\.\d+\.\d+ \Q$socket\E$/;
       }
 
* DONE Make client be able to send single commands to server
  CLOSED: [2024-01-05 Fri 04:18]
  The client should be able to connect, some specified command(s) then
  disconnect, rather than always going into an interactive REPL-mode.
* [7/7] Basic subcommands
  Server commands only take zero or one arg. Client execute multi-arg commands
  as one command for each arg (resulting in one 'OK' or 'ERR' for each arg).
** DONE `rong load FILE...`
   CLOSED: [2024-01-05 Fri 15:21]
** DONE Escape filename when talking client<->server
   CLOSED: [2024-01-05 Fri 18:43]
** DONE `rong list`
   CLOSED: [2024-01-06 Sat 12:55]
** DONE `rong kill FILE...`
   CLOSED: [2024-01-08 Mon 15:01]
** DONE `rong help`
   CLOSED: [2024-01-10 Wed 00:55]
** DONE `rong save FILE`
   CLOSED: [2024-01-10 Wed 01:04]
** DONE `rong cat FILE`
   CLOSED: [2024-01-10 Wed 01:08]
* [13/13] `rong cd DIR` & relative filenames
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:
  All file-specific command accept both relative and absolute filenames. Output
  of 'list' command is relative to client's current dir (which is sent to
  server on connecting, as the server does all file name conversions).
** DONE Use File::Spec for filenames and path handling(?)
   CLOSED: [2024-01-10 Wed 19:52]
   File::Spec is a core module. Use that!
** [6/6] Use absolute paths internally
   CLOSED: [2024-01-10 Wed 19:52]
*** DONE Handle paths better
    The client cannot just always send full paths as args for each command (this
    would make REPL-mode unpleasant to use).

    How to do this? Deal with it on the client side? Or have client send it's
    current directory to the server as it is connecting?
*** DONE `load FILE`
*** DONE `list`
*** DONE `kill FILE`
*** DONE `save FILE`
*** DONE `cat FILE`
** DONE Connection specific options
   CLOSED: [2024-01-12 Fri 19:25]
   These are some config specific to a client-server connection. They are
   initialized when the client connects to the server, and forgotten again when
   a client disconnects. The only setting right now is the current directory of
   the client.

   In interactive mode the user is now able to `cd` somewhere, then have the
   `list` of files be relative to that current directory.
** WONT Better client session ID
   Not really needed, I think? `fileno()` should result in a unique number for
   each open file in the server, regardless of filename. The only benefit of
   using something more elaborate would be a lessened risk of accidentally
   sharing info with the next client to connect (which could happen if the
   previous connection failed to do its cleanup).

   Client session ID should be unique even across multiple sockets (for when we
   start doing that).
** [2/2] Client should always send `cd` command when connecting
   For single commands, issue a `cd $PWD` command before invoking the
   user-requested command(s).
*** DONE Always send initial `cd` from client
    CLOSED: [2024-01-14 Sun 00:03]
*** DONE Suppress output from initial `cd` command
    CLOSED: [2024-01-14 Sun 02:40]
** DONE Use `Cwd::getcwd()` instead of `Cwd:cwd()`
   CLOSED: [2024-01-16 Tue 18:34]
   `Cwd:cwd()` gives a weird error message when invoked from inside a
   non-existing directory:

      /bin/pwd: couldn't find directory entry in ‘..’ with matching i-node

   Also, using `Cwd::cwd()` does not resolve uniquely (since symlinks in the
   path are not resolved). So therefore, use `Cwd::getcwd()` (which does
   resolve all symlinks) instead.
** DONE Handle `~[username]` directories
   CLOSED: [2024-01-17 Wed 05:09]
* DONE `rong list` with no files loaded shouldn't display blank line
  CLOSED: [2024-01-17 Wed 03:26]
* DONE Fix `abspath()`
  CLOSED: [2024-01-17 Wed 05:09]
  Loading a file with a path like `foo/../lala` should result in the loaded
  file having a name which does not include the `..` component.
* DONE `rong list` when current dir is root -- use absolute paths
  CLOSED: [2024-01-17 Wed 05:23]
  When path is '/', display absolute paths.
* DONE Server should log when it starts
  CLOSED: [2024-01-17 Wed 21:33]
* DONE Server should log when it exits/dies
  CLOSED: [2024-01-17 Wed 21:33]
  An `END` block inside the Rong package, should work. But it doesn't fire on
  SIGINT (unless there's a trap, possibly?).

      END { warn "(server exited)\n" unless -t STDERR }
 
* DONE `create_tmpdir()` should use `File::Spec->tmpdir()`
  CLOSED: [2024-01-18 Thu 02:55]
* DONE Use `File::Spec->splitpath()` to get program name
  CLOSED: [2024-01-18 Thu 03:26]
* DONE Use `File::Spec->rootdir()`
  CLOSED: [2024-01-18 Thu 03:45]
* DONE Use `File::Spec` for all file name manipulations
  CLOSED: [2024-01-18 Thu 04:11]
* DONE Empty arg to `escape()` should return ""
  CLOSED: [2024-01-18 Thu 22:22]
* [12/12] Improve subcommands
** DONE Subcommand functions should not be in hash
   CLOSED: [2024-01-19 Fri 22:35]
** DONE `rong` (without args) should start server + list buffers
   CLOSED: [2024-01-19 Fri 20:43]
   This should start the daemon process and then immediately exist the client.
   (Under normal circumstances this command is not needed since a server if it
   isn't already running, when starting a client will start it.)

   Note: In the future we might want a way to name the server socket, so that
   user may run multiple daemons at the same time.
** DONE `rong repl`
   CLOSED: [2024-01-19 Fri 20:43]
   There should be a user greeting, with listing of commands also telling that
   ^C or ^D exists.
** WONT `rong cd` should allow symlink(s) in path
   CLOSED: [2024-01-19 Fri 20:45]
   When `foo` is symlink to `bar/baz` then cd `foo` should set the current dir
   to `foo` (NOT `bar/baz`)

   All symlinks in paths are currently fully expanded before a file is loaded,
   so this isn't needed.
** DONE `rong load` -- Give error in case of non-files & follow symlinks
   CLOSED: [2024-01-17 Wed 18:50]
   `abspath()` already resolved any symlinks in filename. Added errors for
   fifo, device files etc.
** DONE `rong cat` -- Give error when too few args
   CLOSED: [2024-01-20 Sat 00:51]
** DONE `rong kill` -- Give error when too few args
   CLOSED: [2024-01-20 Sat 00:51]
** DONE `rong load` -- Give error when too few args
   CLOSED: [2024-01-20 Sat 00:51]
** DONE `rong save` -- Give error when too few args
   CLOSED: [2024-01-20 Sat 00:51]
** DONE `rong load` -- Handle read errors
   CLOSED: [2024-01-20 Sat 05:12]
   Should any catch any errors gotten while reading (in `<$fh>` statement) too.
** DONE `rong save` -- Handle write errors
   CLOSED: [2024-01-20 Sat 05:12]
   Should any catch errors gotten while writing (in `print` statement) too.
** DONE `rong cd` -- error message(s)
   CLOSED: [2024-01-28 Sun 18:50]
   Decent error message for when dir can't be created because exists, but isn't
   a dir.
* DONE Failing a command should result in non-zero exit status
  CLOSED: [2024-01-20 Sat 06:45]
* [16/16] Make Unicode work (in socket communication)
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:
** DONE Refactor socket creation
   CLOSED: [2024-01-25 Thu 10:15]
   Refactored `connection_socket()` and `listening_socket()`, combining them
   into single function.
** DONE Is `autoflush()` still needed? -- YES
   CLOSED: [2024-01-25 Thu 11:12]
   According to `perlfunc` manpage `sysread()` bypass Perl IO buffering, but
   `perlvar` says autoflush is about OUTPUT, so yes, `autoflush()` is still
   needed.
** DONE Refactor accepting socket connection
   CLOSED: [2024-01-25 Thu 11:50]
** DONE Explicitly decode command line arguments
   CLOSED: [2024-01-26 Fri 01:39]
** DONE Explicitly encode/decode socket communication (and STDIN)
   CLOSED: [2024-01-26 Fri 02:30]
   `sysread()` cannot be used for file handles marked as utf8, meaning that all
    input must be manually decoded.

   Since all sockets use `sysread()`, also read STDIN using `sysread()` (as
   this simplifies code). `sysread()` cannot be used in input marked as utf8,
   so therefore STDIN needs to be set to `:raw` mode using `binmode(STDIN,
   ':raw')`.

   File operations should be used for stream sockets. (`recv()` is meant for
   datagram sockets, which is not what Rong is using).

   See also: https://stackoverflow.com/a/5600853/351162 (diff <>, sysread, rect)
   Raw file read: https://www.perlmonks.org/?node_id=1195588

   On nonblocking sockets and ->connected():
   https://www.ralph-schuster.eu/2015/06/19/nonblocking-sockets-and-perls-netdaemon/

   Webserver with Perl:
   https://redirect.cs.umbc.edu/courses/331/fall12/notes/perl/aWebserverWithPerl.html

   Switched to using recv() for the sockets, but it'd be nicer to use something
   that can be used on both STDIN and socket, to simplify the client REPL-loop.

   Sysread doesn't allow Unicode, but if set up so that just raw bytes are
   shuffled over the socket that shouldn't matter. (The benefit of this is to
   avoid hangs.)
** DONE Explicitly encode output of all subcommands
   CLOSED: [2024-01-26 Fri 05:29]
** DONE Use `syswrite()` when writing to socket
   CLOSED: [2024-01-26 Fri 06:12]
   Were using `sysread()` to read from socket, and this instruction should not
   be mixed with the likes of `print()` -- which is used for buffered IO. Thus
   `syswrite()` must be used.
** [4/4] Refactor `server_main()`
*** DONE Should use `$id` instead of `$fn`
    CLOSED: [2024-01-26 Fri 06:17]
*** DONE `rong::initialize()` should be called with $id as arg
    CLOSED: [2024-01-26 Fri 06:18]
    That is, there should be a separate line `my $id = fileno($fh)`, and then
    it should be called with `rong::initialize($id, $listenfile)`
*** DONE Add error indicator after infinite loop
    CLOSED: [2024-01-26 Fri 06:19]
    If something ever breaks out of the infinite loop, that should (at least)
    print an error in the error log. Add something like the following after the
    loop in `server_main()`.

        die "THIS CANNOT HAPPEN\n";
 
*** DONE When reading, use same variable name
    CLOSED: [2024-01-26 Fri 06:32]
** [5/5] Explicitly encode/decode all dirs, filenames and paths
   Look the use of `__FILE__`, operations done with `File::Spec` and `Cwd`.
   Write wrapper functions that makes sure that all of these functions only
   return strings for which `is_utf8()` returns true.
*** DONE Current dir
    CLOSED: [2024-01-26 Fri 16:07]
*** DONE Root dir
    CLOSED: [2024-01-26 Fri 16:07]
*** DONE Filenames
    CLOSED: [2024-01-28 Sun 16:51]
*** DONE __FILE__
    CLOSED: [2024-01-28 Sun 18:27]
*** DONE Tempdir
    CLOSED: [2024-01-28 Sun 18:27]
* DONE Fix: `THIS CANNOT HAPPEN` warning when server receives SIGTERM
  CLOSED: [2024-01-29 Mon 18:46]
* DONE Accept standard server signals (SIGHUP, SIGINT etc)
  CLOSED: [2024-01-29 Mon 18:47]

  SIGPIPE is received when client disconnects, and needs to be ignored. SIGHUP
  might be received upon backgrounding the server. SIGTERM and SIGINT both
  exits the server.
* DONE Fix: Expanding user directories should always work
  CLOSED: [2024-02-06 Tue 12:15]
  Problem here was `glob()` being called in scalar context, meaning that the
  result would be different on each call. So, now called in list content, and
  the extracting only first result.

  Another problem with the way I used `glob()` to expand `~[user]` directory
  names, is that it allowed other characters that `glob()` treat in a special
  way, so tightened the character class used to find `~[user]` parts of a path.
* DONE Fix: Server greeting should contain protocol name, not binary name
  CLOSED: [2024-02-06 Tue 12:51]
  The greeting word 'rong' is the name of the protocol, not name of the
  program. This is relevant when the binary has been symlinked or rename, as
  the greeting should still contain the protocol name, not whatever name the
  program file has.

  Also renamed protocol 'Rong' (with capital R) to lessen risk of future
  confusion.
* DONE Break out code from inside if `can_read()` statements
  CLOSED: [2024-02-16 Fri 10:44]
  This code is always run, while it looks like a conditional. That's kinda
  misleading.
* DONE Added `exit` command
  CLOSED: [2024-02-16 Fri 14:07]
* DONE Fix: `cmd_help()` shouldn't log `uninitialized value $cmd`
  CLOSED: [2024-02-17 Sat 02:01]
  `cmd_help()` when invoked with zero args logs an `Use of uninitialized value
  $cmd in string eq`. Fix this.
* DONE Refactored `input()` and `send_command()` and verified their calls
  CLOSED: [2024-02-17 Sat 02:22]
* [18/22] Improve error messages & help
** DONE Fix faulty error messages (`__DIE__` hook double rewrite)
   CLOSED: [2024-01-18 Thu 22:17]
   Giving incorrect args to a command inserts 'rong:' twice in the error
   output. Fix this:

       $ rong list BLA
       rong list BLA: rong: No args allowed

   Was the result of a `$SIG{__DIE__}` hook being invoked inside an `eval { }`
   block.
** DONE Better sigdie handling
   CLOSED: [2024-01-19 Fri 19:46]
   Instead of having to `local $SIG{__DIE__} = 'DEFAULT'` inside of each eval
   block, the sigdie handler should detect that it was called from inside an
   eval, and not do it's usual error message rewriting.

   It was surprisingly hard to find a good description of how to avoid this,
   but I finally found it, hidden away in the perlfunc manpage (under the
   description of `die` function). Rather than giving a full code example, the
   manpage simply states that one should add the line `die @_ if $^S;` as the
   first line of any `$SIG{__DIE__}` handler.

   While searching for a way to do this I found the special Perl variable
   `$^S`, but had a hard time finding any more info since special characters
   aren't very googlable. I did find the following pages helpful though:

     + [[https://www.perlmonks.org/?node_id=51097][Perl's Warn and Die Signals (on Perlmonks)]]
     + [[https://www.perlmonks.org/?node_id=42411][SIGDIE (on Perlmonks)]]
     + perlfunc manpage (at end of description for `die`)
     + perlvar manpage (both under `%SIG` and `$^S`)
 
** DONE Sigdie handling should be setup at beginning of main
   CLOSED: [2024-01-19 Fri 20:14]
** DONE Make error messages more user friendly
   CLOSED: [2024-01-20 Sat 08:15]
   When invoking command from the command line, like so

       $ rong list osuh
       rong list osuh: No args allowed

   The error message should more similar to when an incorrect option was given:

       $ rong --osuhou
       rong: Unrecognized option '--osuhou'
       Try 'rong help' for more information.

   Something more like this:

       $ rong list osuh
       rong list "osuh": No args allowed
       Try 'rong help list' for more information.
 
** DONE More pedagogical server greeting
   CLOSED: [2024-01-30 Tue 11:31]
   When user connect in REPL mode, the server greeting should indicate that ^D
   is used to quit, and that `help` can be used for additional info.
** DONE Make client server-version agnostic
   CLOSED: [2024-02-02 Fri 14:11]
   The client needs a list of available commands from the server in order to
   parse the command line. To decouple the client and server completely, the
   client should ask the server for the available commands and use this info to
   parse the command line.

   There's gonna be a variable number of arguments for different server
   commands. Some will only ever take one arg ('load', 'save' etc.) some zero
   or one ('cd'), some two ('mv', 'cp' -- moar?).

   Rather than doing complicated tricks here, just give the entire command line
   to the server (minus any leading options intended for the Rong client), and
   let the server deal with it, returning any appropriate errors.
** DONE `Unrecognized command` should include help info on command line
   CLOSED: [2024-02-07 Wed 16:16]
** DONE `rong help COMMAND` info
   CLOSED: [2024-02-09 Fri 11:18]
** DONE Fetch help info from server
   CLOSED: [2024-02-09 Fri 11:18]
   The command information should be read from the server, so that the REPL
   will show the same help info as the command line client.
** WONT Pass %opt into `cmd_*` functions -- NO
   CLOSED: [2024-02-09 Fri 12:57]
   Currently `rong::cmd_*` functions return docstring if called with args.
   Instead of passing the connection id as the first arg, should pass `%opt`
   with an 'id' property set, and 'help' set to make it pass the docstring.

   WHY NOT? No, the above is silly. Functions are invoked by the server which
   have no info beyond what was passed via the protocol (i.e. any `--help`
   option given to the client is not an option to be passed to the server). The
   above idea was just me confusing the levels of indirection.
** DONE `rong help` -- Detailed help info
   CLOSED: [2024-02-09 Fri 14:12]
   The detailed help info should provide the same info about the commands as is
   available from the command line using the `--help` option. (In fact, the
   `--help` option should fetch *its* help info from the server process, so as
   to make the client server-version agnostic.)

   The help output is this mode should preferably be the same as with command
   line help, e.g. `rong help load` should show the same text as `help load` in
   REPL-mode, and `rong help` and `rong --help` should show the same as `help`
   in REPL mode.
** DONE Fix: `help()` function should invoke `send_command()`
   CLOSED: [2024-02-09 Fri 14:12]
   Currently `send_command()` is invoked before `help()` and the result of
   `send_command()` is passed on to `help()` -- this is only done because
   invoking `send_command()` from inside `help()` doesn't work, for unknown
   reason. Fix this.

   This didn't work because of a prototype error. `send_command()` uses a
   prototype, which means that it needs to be declared be before any function
   that calls it. (Which wasn't the case with `help()`.) Fixed by adding an
   early prototype declaration.
** DONE Option `--help` and command `help` should give same output
   CLOSED: [2024-02-09 Fri 14:12]
   When this is done the "Try 'rong --help' for more information." should say
   `rong help` and `rong help COMMAND` rather than the current `rong --help`.

   Currently `rong help` outputs the info one would expect in the REPL, rather
   than what one would expect on the command line.
** DONE `rong --help COMMAND`
   CLOSED: [2024-02-09 Fri 14:12]
   Should give help info on the specified COMMAND.
** DONE `Unrecognized command` should include help info in REPL(?)
   CLOSED: [2023-06-03 Sat 16:07]
   Add "('help' for info.)" to the end of the error message in REPL mode.
** DONE Error messages from `repl` and other subcommands should look the same
   CLOSED: [2023-06-03 Sat 16:07]
   Currently there's a difference in error messages between client-only
   commands (only `repl` at this point in time), and server commands. These
   should look the same:

       $ rong repl ga
       rong: No args allowed
       Try 'rong --help' for more information.

   (The above is missing the full `rong repl` command in the error message.)

       $ rong list ga
       rong list ga: No args allowed
 
** DONE Include `repl` command in help
   CLOSED: [2024-02-16 Fri 19:26]
** DONE Document each command more thoroughly
   CLOSED: [2024-02-16 Fri 19:26]
** TODO Make REPL also have implicit commands
   Just pressing enter in REPL mode should invoke `list`, specifying filenames
   (without a command) should equal `load` (just as with the command line).

   The reason for doing this is just to simplify the code, as the exact same
   help info becomes applicable to both REPL mode and the command line
   (eliminating the need for rewriting it in one of the contexts).

   It also pushes the command logic to the server side (which is fine, if
   neutral in its effects).

   The con of the whole thing would be that this isn't really how one expect a
   protocol to behave, but whatevs.
** TODO Accept multiple filenames in REPL mode for file commands
   `cat`, `kill`, `load`, `save`
** TODO Option `--version` should report both server and client versions
** TODO Failure when loading a symlink
   When attempting to load a symlinked file that points to a file that is
   already loaded, the error message isn't very helpful. Look at the following:

       $ rong
       README.txt
       $ ls -h le
       lrwxrwxrwx 1 zrajm zrajm 9 2024-01-17 18:46 le -> README.md
       $ rong le
       rong load le: File already loaded

   The error message should include that Rong attempted to load.
* TODO Rename `repl` command `shell`
  Also update all mentions of REPL in the docs to instead say 'shell' or 'Rong
  shell'.
* [0/1] `rong select`
  Should be able to select files, and section of files. Any subsequent
  operations would then be performed on the selection only.
** TODO `rong select [FILE][:(LINE[.COL][..LINE2[.COL2]]|NAME)]`
   Select FILE or part of FILE. If `LINE` or `LINE..LINE2` is given, select the
   corresponding lines (with COL specifying the column, and negative numbers
   counting backwards from the end). If NAME is given, select the function
   called NAME (from the name of the function to the end of it).

   `NAME` supports functions in: C, Javascript, Perl, Python and the Shell.
   (Javascript also allows for the `NAME = function (...) {...}` and
   `NAME = (...) => { ... }` form.)
* [0/4] Improve log
** TODO Log each invoked command
** TODO Don't include path for each log event
** TODO More unique non-repeating client id?
   Meaning commands can be tied to a specific client connection, and other
   commands of that client connection can be easily located.q
** TODO Time for each logged event
* [0/5] Search/replace (1st editing capability)
** TODO Allow multiple args in `invoke()`
   In order to make a command with multiple arguments work, a rewrite of
   `invoke()` function is needed, so that a command line only ever invokes one
   `cmd_` function, rather than invoke one command for each file.

   This means that the error message must contain the name of the file related
   to the error.
** TODO Include name of file in error messages
** TODO `rong replace PATTERN REPLACEMENT`
** TODO Undo

   + Never lose redo history: Editing after undoing should not lose the redo
     history. (Similar to the way Emacs does this.) Edit history should be in
     the shape of a tree.

   + Separate undo histories for separate views: If two views of the same file
     is open, they should not affect each other. Undoing a change, should not
     undo a change done in a different view.

   + Selective undo: User should be able to select an area, then perform undo
     to only the changes made in this area.

   There should be a history viewer, where one can:
   + Look at the complete history (all views, all changes) with the changes
     belonging to the current view highlighted.
   + Look at the history for only this view (excluding any other changes).
   + Look at changes being done in a specific time interval.

   When reloading a file: Find the differences with the old version, and
   incorporate this as an undoable action in the file's edit history.

   What structure to use?

   + [[https://github.com/zaboople/klonk/blob/master/TheGURQ.md][Resolving the Great Undo-Redo Quandary (GURQ)]] -- This article describes
     the UI of something that works like Emacs undo function. (Can we do better
     than this?)

   To quote https://news.ycombinator.com/item?id=33561897:

       In Emacs, undo makes an undo pointer go down in the undo stack. Pressing
       undo again goes back another step. If you do any other regular edit, the
       pointer starts over at the top of the undo stack. Undo puts its own
       edits on top of the stack like any other command.

       So if you "undo, undo" you undo two things. If you "undo, edit, undo",
       you're keeping the first undo but reverse the edit. If you "undo, edit,
       undo, undo", you're back to where you started (except your undo stack
       has now grown).
 
** TODO Diffing the undo
* [0/3] Atomic saves + `rename` & `copy`
** TODO `rong save` -- Make atomic
   There should maybe be a `--no-atomic` option to override atomic saves
   (useful for situation with very full disk, where one just wants to override
   the old data).
** TODO `rong rename`
** TODO `rong copy`
* [3/4] Multi-line responses over the socket
** DONE Create and document multi-line protocol responses
   CLOSED: [2024-02-02 Fri 13:48]
   Added "Protocol" section to the README.
** DONE A standardized format for multi-line responses
   CLOSED: [2024-02-04 Sun 23:24]
   Implemented a scheme for multi-line server responses. Documented in the
   `README.md` under the heading 'Protocol'.

   The `perlipc` manpage says:

       If you're not writing a server/client for an existing protocol like NNTP
       or SMTP, you should give some thought to how your server will know when
       the client has finished talking, and vice-versa. Most protocols are
       based on one-line messages and responses (so one party knows the other
       has finished when a "\n" is received) or multi-line messages and
       responses that end with a period on an empty line ("\n.\n" terminates a
       message/response).

   Furthermore, the escaping of any periods are done by the client adding a
   leading period to any line starting with a period, and the server then
   stripping leading periods off of lines which consist of more than just a
   single period. (RFC2821, chapter "4.5.2 Transparency"
   https://www.ietf.org/rfc/rfc2821.txt)
** DONE `rong cat` -- Output files without final newline
   CLOSED: [2024-02-06 Tue 21:55]
   Doing `rong cat` should respect any lack of a newline at the end of the
   file. That is, if a file is loaded, then outputted by means of `rong cat`,
   the outputted text should be identical to the original file.
** TODO Formalize escapes in protocol
   Server and client should speak in the same way. Does the client->server
   escaping/unescaping still make sense? Should client messages use multi-line
   messages that look the same as those coming from server?
* [0/4] Make sure the sockets are used correctly
  Read up on sockets: https://docstore.mik.ua/orelly/perl4/cook/ch17_04.htm
** TODO Overview
   Many of the syscalls used for sockets have very cursory descriptions in
   `perlfunc` but are more thoroughly described in individual manpages: `recv`,
   `send` etc.

   Sockets are subject to both `stdio` buffering (which can be turned off with
   `$fh->autoflush(1)` -- which is needed when using a line-based protocol) and
   buffering at the operating system level (which, for TCP-sockets, can be
   disabled with the socket option TCP_NODELAY -- though this should only be
   done for applications that send real-time data, such as mouse movements or
   individual key presses).

   There are two types of sockets (Rong uses a streaming socket).

   + Streams (TCP-like)
     - Use file functions (except `seek` and `sysseek`).

   + Datagram (UDP-like)
     - Use `send()` and `recv()`.
 
** TODO Are credentials needed, or is socket file access enough?
** TODO How send byte-by-byte real-time data through socket? (for interactive mode)
** TODO How make client detect when server disappear? (to abort immediately)
   Source from: https://www.perlmonks.org/?node_id=11106953
   Here the client have a 2 second timeout, and disconnects if server does not
   respond within that time frame. This is probably not the method to use.

       #!/usr/bin/perl
       use strict;
       use warnings;
       use IO::Socket::UNIX;
       use constant SOCKET => 'test_socket.sock';
       my $mode = shift or die "Specify a mode\n";
       if ($mode eq 'server') {
           my $server = IO::Socket::UNIX->new(
               Type    => SOCK_STREAM,
               Local   => SOCKET,
               Listen  => 1,
               Timeout => 2,
           ) or die $!;
           while (my $conn = $server->accept()) {
               my $name = <$conn>;
               print {$conn} "Hello $name";
               close $conn;
           }
           print 'Timed out', "\n";
       }
       elsif ($mode eq 'client') {
           my $client = IO::Socket::UNIX->new(
               Type    => SOCK_STREAM,
               Peer    => SOCKET,
           ) or die $!;
           print {$client} 'John', "\n";
           print "Got reponse: ", scalar <$client>;
           close $client;
       }
       else {
           die "Unsupported mode: $mode\n";
       }
 
* [0/7] Protocol
** TODO Format: Raw mode? (for visual editor clients)
   Telnet protocol apparently have a line-based and a raw mode. How does that
   work?
** TODO Selection commands
** TODO Cursor move commands
** TODO Text insertion
** TODO Text deletion
** TODO Server pushes (client should be able to subscribe to events)
   This needs to be specified on a file level. Also, a client that isn't
   displaying a certain file should be able to unsubscribe, then resubscribe
   and ask for updates when a user starts editing that file again.
** TODO Separate protocol logic from server specifics
   The client and server skeleton logic should be in a separate module, and the
   specifics should be separated out into its own module.
* [0/3] Change-based `load` and `save` commands
** TODO Implement file fingerprinting
   When loading a file ctime and a file fingerprint should also be remembered,
   then used for intelligently deciding when to save, or reload a file.
** TODO `rong load` -- Reload if file has changed (and buffer hasn't)
   When doing `rong load FILE` on an already loaded file, don't display error
   message:

       rong: Command 'load': File already loaded

   But instead check to see if file has been modified on disk, and if it has
   reload it.

   This should use fingerprinting, but do a checksum if fingerprint fails. That
   is, if file is identical to existing one, it should *never* be reloaded.
   (Instead a message should be given to the user.)
** TODO `rong save` -- Save if buffer has changed (but file hasn't)
   This should use fingerprinting, but do a checksum if fingerprint fails. That
   is, if file is identical to existing one, it should *never* be saved again.
   (Instead a message should be given to the user.)
* TODO `rong list` option to display absolute paths
* TODO All clients should die (immediately) if server dies
  Maybe temporarily add a die command to test this on the server side?

  If not doing `chomp($x)` after reading STDIN in REPL-mode, and calling
  `deserialize()` before the `eval { }` in `invoke()` the first command in
  REPL-mode will work, but the second will crash the server.

  Is using $fh->connected to verify that we're still connected the way to do
  it?
* TODO Make sure error message is intelligible if initial `cd` fails
  This will happen if the current directory doesn't exist when starting rong.
* TODO Command to check if server is running (without starting it)
* TODO Escaping should use same schema as shell or 'ls' command
  To make it make when using `rong list`.
* [0/10] FAR-FLUNG FUTURE FEATURES
** TODO Suppress build-in warnings from `syswrite()`
   `syswrite()` write warnings to STDERR if there's an error (e.g. writing on a
   closed filehandle). This should instead be handled our own error messages,
   with the build-in warnings suppressed. However, these errors should be rare
   enough that it's not a high priority.
** TODO If socket file is deleted, should server re-create it(?)
** TODO Better server signal handling?
   Resist SIGTERM! This is so that `pkill rong` kills client processes but not
   the server.

   From: https://docstore.mik.ua/orelly/perl/cookbook/ch16_01.htm

   SIGINT: is normally triggered by Ctrl-C. This requests that a process
     interrupt what it's doing. Simple programs like filters usually just die,
     but more important ones like shells, editors, or FTP programs usually use
     SIGINT to stop long-running operations so you can tell them to do
     something else.

   SIGQUIT: is also normally generated by a terminal, usually Ctrl-\. Its
     default behavior is to generate a core dump.

   SIGTERM: is sent by the kill shell command when no signal name is explicitly
     given. Think of it as a polite request for a process to die. SIGUSR1 and

   SIGUSR2: are never caused by system events, so user applications can safely
     use them for their own purposes.

   SIGPIPE: is sent by the kernel when your process tries to write to a pipe or
     socket when the process on the other end has closed its connection,
     usually because it no longer exists.

   SIGALRM: is sent when the timer set by the alarm function expires, as
     described in Recipe 16.21.

   SIGHUP: is sent to a process when its controlling terminal gets a hang-up
     (e.g., the modem lost its carrier), but it also often indicates that a
     program should restart or reread its configuration.

   SIGCHLD: is probably the most important signal when it comes to low-level
     systems programming. The system sends your process a SIGCHLD when one of
     its child processes stops running - or, more likely, when that child
     exits. See Recipe 16.19 for more on SIGCHLD.
** TODO Use `shutdown()` to close socket?
   https://docstore.mik.ua/orelly/perl/cookbook/ch17_10.htm
** TODO On startup make sure any existing tempdir is chmod 0700
   Function: create_tempdir() -- Easiest is maybe to just 'chmod 0700' the
   directory if it exists on startup?
** TODO Use Perl -T (taint flag) for the server
    Manpage perlipc says this is a good idea:

    > You should use the `-T` flag to enable taint checking (see perlsec) even
    > if we aren't running setuid() or setgid(). This is always a good idea for
    > servers or any program run on behalf of someone else (like CGI scripts),
    > because it lessens the chances that people from the outside will be able
    > to compromise your system.
 
** TODO Client authentication
   Is being able to connect to the socket enough of an authentication?
** TODO Keep track of open connections, die when last has exited(?)
   But don't die before first client has connected.
** TODO Change client directory to root
   Clients should remember their starting directory, but change dir to '/' so
   that their original dir can be unmounted etc.
** TODO Use locale settings?
   Should all input be UTF-8, or should we use locales? What happens to file
   system encoding of filenames -- assume that to be the same as the locale?
** [0/2] Improve `input()`
*** TODO Mirroring mode (optimization for large files)
    Data read by `input()` is returned as function return value. This could be
    a problem for really large files, as all data must be handled at the same
    time, and cannot be processed piecemeal.

    The input function should have a mirror mode in which input is processed
    and output line by line, so that not all of the data need to be in the
    client's memory running `cat`.
*** TODO Buffering (for splitting input)
    Currently, if multiple lines are delivered fast enough to be read by the
    same `sysread()`, then these are not split apart into separate responses (as
    they should be). -- This will probably work just fine in most instances.

    But, in the future (especially if there are push events coming from the
    server) read input might have to be split if there are multiple responses
    read in one `sysread()`.

    Also, remember to clear any server-side buffer when a client is
    disconnected.
* [0/2] TESTS
** TODO Use the modulino pattern to make program testable
** TODO Resolving absolute paths
   Then resolving any `/../` parts of a path, there's a corner case involving
   symlinks that needs to be considered. Here a description from the manpage
   File::Spec(3perl)

       Note that this does *not* collapse `x/../y` sections into `y`. This is
       by design. If `/foo` on your system is a symlink to `/bar/baz`, then
       `/foo/../quux` is actually `/bar/quux`, not `/quux` as a naive
       `../`-removal would give you. If you want to do this kind of processing,
       you probably want "Cwd"'s "realpath()" function to actually traverse the
       filesystem cleaning up paths like this.
 
* [eof]
