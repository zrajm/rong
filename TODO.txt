-*- org -*-

* DONE Make client read from both STDIN and server at same time
  CLOSED: [2023-12-31 Sun 15:49]
  This is done using IO::Select.
* DONE Listen to multiple incoming connections (without threading)
  CLOSED: [2023-12-31 Sun 15:49]
  This is done using IO::Select, and the code was adapted from final example
  code on the IO::Select manpage.
* [6/6] Daemonize server completely
  CLOSED: [2024-01-01 Mon 09:13]
  From: https://theworld.com/~swmcd/steven/tech/daemon.html
  (Though I added wait() to reap the intermediate process.)

        use POSIX 'setsid';
        sub daemonize {
            fork and do { wait; return };
            POSIX::setsid();
            fork and exit;
            umask 0;
            chdir '/';
            close STDIN;
            close STDOUT;
            close STDERR;
        }
 
** DONE 1. Fork intermediate process
   `fork` -- The first fork allows the child to run the daemon while the parent
   continues execution, or exits. In addition, it ensures that the child is not
   a process group leader, so that the following `setsid()` call will succeed.

   I also added a `wait` call in the invoking client process, so as to reap the
   intermediate process and never leave a zombie process in the process table.
** DONE 2. Create new process session
   `setsid` -- This is how we lose our controlling terminal. `setsid` makes our
   process the session leader of a new session, and when a new session is
   created, the session leader has no controlling terminal.
** DONE 3. Fork server process
   `fork` -- The leader of a new session has no controlling terminal, but it
   could acquire one, for example, by opening `/dev/tty` or the like. To ensure
   that this doesn't happen, we fork again.

   After the second fork, the child is not the session leader (the parent is
   the session leader) and only a session leader can acquire a controlling
   terminal. Of course, the child could become a session leader by executing
   `setsid` again, but presumably anyone who does that knows what they are
   doing.
** DONE 4. Reset umask
   `umask 0` -- `umask` is inherited across `fork` and `exec`, and we don't
   want our daemon to be limited by whatever `umask` it happens to inherit from
   its parent.
** DONE 5. Change dir to '/'
   `chdir '/'` -- The current working directory is inherited across `fork` and
   `exec`. If we leave the daemon running in some random directory, then the
   file system that contains that directory can never be `umounted`, and
   someone might want to.
** DONE 6. Close standard streams
   `close` -- Even though the daemon has no controlling terminal, it may still
   have open file descriptors on a terminal, and these can cause trouble. For
   reliable operation, close the system file descriptors.
* DONE Simple server logging to tempdir
  CLOSED: [2024-01-01 Mon 11:02]
  Store a log as a buffer? Log to a file? Write status stuff into
  notifications? Have a client log mode, so that all error messages are sent to
  all log-receiving clients?
* DONE Git commit hook to validate $VERSION before commit
  CLOSED: [2024-01-01 Mon 15:55]
* DONE Redirect server STDERR to logfile
  CLOSED: [2024-01-04 Thu 09:42]
  So that error messages wind up there. (STDOUT is not important, since the
  logfile filehandle is selected and the output of print() and friends
  therefore already winds up in the logfile.)

  Took the approach exemplified by the following snippet in the perlipc(1)
  manpage (except that I'm closing STDIN rather than reading from /dev/null).

      sub daemonize {
          chdir("/")                     || die "can't chdir to /: $!";
          open(STDIN,  "<", "/dev/null") || die "can't read /dev/null: $!";
          open(STDOUT, ">", "/dev/null") || die "can't write /dev/null: $!";
          defined(my $pid = fork())      || die "can't fork: $!";
          exit if $pid;              # non-zero now means I am the parent
          (setsid() != -1)           || die "Can't start a new session: $!";
          open(STDERR, ">&", STDOUT) || die "can't dup stdout: $!";
      }
 
* DONE Client-server protocol basics
  CLOSED: [2024-01-04 Thu 10:43]
  + Server starts when client connect, sends `OK rong <VERSION> <SOCKET>`
  + All server responses is single line, starting with 'OK' or 'ERR'
* DONE Server greeting
  CLOSED: [2024-01-04 Thu 10:43]
  Upon connecting the server should send a greeting containing server name and
  version number. E.g. `OK rong 0.0.10 /tmp/rong-1000/default`.
* DONE Verify server greeting when connecting
  CLOSED: [2024-01-05 Fri 00:30]
   When a client connects to the server it should verify the returned greeting
   using something like:

       # Verify server greeting.
       if ($sockets->can_read) {
           defined(my $greeting = <$server>)
               or die "Cannot read server greeting: $!\n";
          die "Cannot understand server greeting\n",
              "    expected: OK rong #.#.# $socket\n",
              "    but got : $greeting"
              unless $greeting =~ /^OK rong \d+\.\d+\.\d+ \Q$socket\E$/;
       }
 
* DONE Make client be able to send single commands to server
  CLOSED: [2024-01-05 Fri 04:18]
  The client should be able to connect, some specified command(s) then
  disconnect, rather than always going into an interactive REPL-mode.
* [6/6] Basic subcommands
  Server commands only take zero or one arg. Client execute multi-arg commands
  as one command for each arg (resulting in one 'OK' or 'ERR' for each arg).
** DONE `rong load FILE...`
   CLOSED: [2024-01-05 Fri 15:21]
** DONE Escape filename when talking client<->server
   CLOSED: [2024-01-05 Fri 18:43]
** DONE `rong list`
   CLOSED: [2024-01-06 Sat 12:55]
** DONE `rong kill FILE...`
   CLOSED: [2024-01-08 Mon 15:01]
** DONE `rong help`
   CLOSED: [2024-01-10 Wed 00:55]
** DONE `rong save FILE`
   CLOSED: [2024-01-10 Wed 01:04]
** DONE `rong cat FILE`
   CLOSED: [2024-01-10 Wed 01:08]
* [13/13] `rong cd DIR` & relative filenames
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:
  All file-specific command accept both relative and absolute filenames. Output
  of 'list' command is relative to client's current dir (which is sent to
  server on connecting, as the server does all file name conversions).
** DONE Use File::Spec for filenames and path handling(?)
   CLOSED: [2024-01-10 Wed 19:52]
   File::Spec is a core module. Use that!
** [6/6] Use absolute paths internally
   CLOSED: [2024-01-10 Wed 19:52]
*** DONE Handle paths better
    The client cannot just always send full paths as args for each command (this
    would make REPL-mode unpleasant to use).

    How to do this? Deal with it on the client side? Or have client send it's
    current directory to the server as it is connecting?
*** DONE `load FILE`
*** DONE `list`
*** DONE `kill FILE`
*** DONE `save FILE`
*** DONE `cat FILE`
** DONE Connection specific options
   CLOSED: [2024-01-12 Fri 19:25]
   These are some config specific to a client-server connection. They are
   initialized when the client connects to the server, and forgotten again when
   a client disconnects. The only setting right now is the current directory of
   the client.

   In interactive mode the user is now able to `cd` somewhere, then have the
   `list` of files be relative to that current directory.
** WONT Better client session ID
   Not really needed, I think? `fileno()` should result in a unique number for
   each open file in the server, regardless of filename. The only benefit of
   using something more elaborate would be a lessened risk of accidentally
   sharing info with the next client to connect (which could happen if the
   previous connection failed to do its cleanup).

   Client session ID should be unique even across multiple sockets (for when we
   start doing that).
** [2/2] Client should always send `cd` command when connecting
   For single commands, issue a `cd $PWD` command before invoking the
   user-requested command(s).
*** DONE Always send initial `cd` from client
    CLOSED: [2024-01-14 Sun 00:03]
*** DONE Suppress output from initial `cd` command
    CLOSED: [2024-01-14 Sun 02:40]
** DONE Use `Cwd::getcwd()` instead of `Cwd:cwd()`
   CLOSED: [2024-01-16 Tue 18:34]
   `Cwd:cwd()` gives a weird error message when invoked from inside a
   non-existing directory:

      /bin/pwd: couldn't find directory entry in ‘..’ with matching i-node

   Also, using `Cwd::cwd()` does not resolve uniquely (since symlinks in the
   path are not resolved). So therefore, use `Cwd::getcwd()` (which does
   resolve all symlinks) instead.
** DONE Handle `~[username]` directories
   CLOSED: [2024-01-17 Wed 05:09]
* DONE `rong list` with no files loaded shouldn't display blank line
  CLOSED: [2024-01-17 Wed 03:26]
* DONE Fix `abspath()`
  CLOSED: [2024-01-17 Wed 05:09]
  Loading a file with a path like `foo/../lala` should result in the loaded
  file having a name which does not include the `..` component.
* DONE `rong list` when current dir is root -- use absolute paths
  CLOSED: [2024-01-17 Wed 05:23]
  When path is '/', display absolute paths.
* DONE Server should log when it starts
  CLOSED: [2024-01-17 Wed 21:33]
* DONE Server should log when it exits/dies
  CLOSED: [2024-01-17 Wed 21:33]
  An `END` block inside the Rong package, should work. But it doesn't fire on
  SIGINT (unless there's a trap, possibly?).

      END { warn "(server exited)\n" unless -t STDERR }
 
* DONE `create_tmpdir()` should use `File::Spec->tmpdir()`
  CLOSED: [2024-01-18 Thu 02:55]
* DONE Use `File::Spec->splitpath()` to get program name
  CLOSED: [2024-01-18 Thu 03:26]
* DONE Use `File::Spec->rootdir()`
  CLOSED: [2024-01-18 Thu 03:45]
* DONE Use `File::Spec` for all file name manipulations
  CLOSED: [2024-01-18 Thu 04:11]
* DONE Empty arg to `escape()` should return ""
  CLOSED: [2024-01-18 Thu 22:22]
* [12/12] Improve subcommands
** DONE Subcommand functions should not be in hash
   CLOSED: [2024-01-19 Fri 22:35]
** DONE `rong` (without args) should start server + list buffers
   CLOSED: [2024-01-19 Fri 20:43]
   This should start the daemon process and then immediately exist the client.
   (Under normal circumstances this command is not needed since a server if it
   isn't already running, when starting a client will start it.)

   Note: In the future we might want a way to name the server socket, so that
   user may run multiple daemons at the same time.
** DONE `rong repl`
   CLOSED: [2024-01-19 Fri 20:43]
   There should be a user greeting, with listing of commands also telling that
   ^C or ^D exists.
** WONT `rong cd` should allow symlink(s) in path
   CLOSED: [2024-01-19 Fri 20:45]
   When `foo` is symlink to `bar/baz` then cd `foo` should set the current dir
   to `foo` (NOT `bar/baz`)

   All symlinks in paths are currently fully expanded before a file is loaded,
   so this isn't needed.
** DONE `rong load` -- Give error in case of non-files & follow symlinks
   CLOSED: [2024-01-17 Wed 18:50]
   `abspath()` already resolved any symlinks in filename. Added errors for
   fifo, device files etc.
** DONE `rong cat` -- Give error when too few args
   CLOSED: [2024-01-20 Sat 00:51]
** DONE `rong kill` -- Give error when too few args
   CLOSED: [2024-01-20 Sat 00:51]
** DONE `rong load` -- Give error when too few args
   CLOSED: [2024-01-20 Sat 00:51]
** DONE `rong save` -- Give error when too few args
   CLOSED: [2024-01-20 Sat 00:51]
** DONE `rong load` -- Handle read errors
   CLOSED: [2024-01-20 Sat 05:12]
   Should any catch any errors gotten while reading (in `<$fh>` statement) too.
** DONE `rong save` -- Handle write errors
   CLOSED: [2024-01-20 Sat 05:12]
   Should any catch errors gotten while writing (in `print` statement) too.
** DONE `rong cd` -- error message(s)
   CLOSED: [2024-01-28 Sun 18:50]
   Decent error message for when dir can't be created because exists, but isn't
   a dir.
* DONE Failing a command should result in non-zero exit status
  CLOSED: [2024-01-20 Sat 06:45]
* [16/16] Make Unicode work (in socket communication)
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:
** DONE Refactor socket creation
   CLOSED: [2024-01-25 Thu 10:15]
   Refactored `connection_socket()` and `listening_socket()`, combining them
   into single function.
** DONE Is `autoflush()` still needed? -- YES
   CLOSED: [2024-01-25 Thu 11:12]
   According to `perlfunc` manpage `sysread()` bypass Perl IO buffering, but
   `perlvar` says autoflush is about OUTPUT, so yes, `autoflush()` is still
   needed.
** DONE Refactor accepting socket connection
   CLOSED: [2024-01-25 Thu 11:50]
** DONE Explicitly decode command line arguments
   CLOSED: [2024-01-26 Fri 01:39]
** DONE Explicitly encode/decode socket communication (and STDIN)
   CLOSED: [2024-01-26 Fri 02:30]
   `sysread()` cannot be used for file handles marked as utf8, meaning that all
    input must be manually decoded.

   Since all sockets use `sysread()`, also read STDIN using `sysread()` (as
   this simplifies code). `sysread()` cannot be used in input marked as utf8,
   so therefore STDIN needs to be set to `:raw` mode using `binmode(STDIN,
   ':raw')`.

   File operations should be used for stream sockets. (`recv()` is meant for
   datagram sockets, which is not what Rong is using).

   See also: https://stackoverflow.com/a/5600853/351162 (diff <>, sysread, rect)
   Raw file read: https://www.perlmonks.org/?node_id=1195588

   On nonblocking sockets and ->connected():
   https://www.ralph-schuster.eu/2015/06/19/nonblocking-sockets-and-perls-netdaemon/

   Webserver with Perl:
   https://redirect.cs.umbc.edu/courses/331/fall12/notes/perl/aWebserverWithPerl.html

   Switched to using recv() for the sockets, but it'd be nicer to use something
   that can be used on both STDIN and socket, to simplify the client REPL-loop.

   Sysread doesn't allow Unicode, but if set up so that just raw bytes are
   shuffled over the socket that shouldn't matter. (The benefit of this is to
   avoid hangs.)
** DONE Explicitly encode output of all subcommands
   CLOSED: [2024-01-26 Fri 05:29]
** DONE Use `syswrite()` when writing to socket
   CLOSED: [2024-01-26 Fri 06:12]
   Were using `sysread()` to read from socket, and this instruction should not
   be mixed with the likes of `print()` -- which is used for buffered IO. Thus
   `syswrite()` must be used.
** [4/4] Refactor `server_main()`
*** DONE Should use `$id` instead of `$fn`
    CLOSED: [2024-01-26 Fri 06:17]
*** DONE `rong::initialize()` should be called with $id as arg
    CLOSED: [2024-01-26 Fri 06:18]
    That is, there should be a separate line `my $id = fileno($fh)`, and then
    it should be called with `rong::initialize($id, $listenfile)`
*** DONE Add error indicator after infinite loop
    CLOSED: [2024-01-26 Fri 06:19]
    If something ever breaks out of the infinite loop, that should (at least)
    print an error in the error log. Add something like the following after the
    loop in `server_main()`.

        die "THIS CANNOT HAPPEN\n";
 
*** DONE When reading, use same variable name
    CLOSED: [2024-01-26 Fri 06:32]
** [5/5] Explicitly encode/decode all dirs, filenames and paths
   Look the use of `__FILE__`, operations done with `File::Spec` and `Cwd`.
   Write wrapper functions that makes sure that all of these functions only
   return strings for which `is_utf8()` returns true.
*** DONE Current dir
    CLOSED: [2024-01-26 Fri 16:07]
*** DONE Root dir
    CLOSED: [2024-01-26 Fri 16:07]
*** DONE Filenames
    CLOSED: [2024-01-28 Sun 16:51]
*** DONE __FILE__
    CLOSED: [2024-01-28 Sun 18:27]
*** DONE Tempdir
    CLOSED: [2024-01-28 Sun 18:27]
* DONE Fix `THIS CANNOT HAPPEN` warning when server receives SIGTERM
  CLOSED: [2024-01-29 Mon 18:46]
* TODO Make sure 2nd arg of `input()` is used where needed
* [0/4] Improve log
** TODO Log each invoked command
** TODO Don't include path for each log event
** TODO More unique non-repeating client id?
   Meaning commands can be tied to a specific client connection, and other
   commands of that client connection can be easily located.q
** TODO Time for each logged event
* [0/2] Search/replace (1st editing capability)
** TODO Search/replace
** TODO Undo
* [0/3] Atomic saves + `rename` & `copy`
** TODO `rong save` -- Make atomic
   There should maybe be a `--no-atomic` option to override atomic saves
   (useful for situation with very full disk, where one just wants to override
   the old data).
** TODO `rong rename`
** TODO `rong copy`
* [0/3] Multi-line responses over the socket
** TODO A standardized format for multi-line responses
   The socket protocol should allow for multi-line output from the server. This
   requires a change in the trailing OK/ERR message, as the OK/ERR is no longer
   at the beginning of the last line when the final line outputted by `rong
   cat` does not end in a newline.

   How do other line-based protocols deal with this?

   This would be used by the `rong cat` and `rong help` commands. For `rong
   cat` it might also be less resource consuming to output a buffer (in
   `cmd_cat()`) line-by-line:

        main::output $_ foreach @{$buf{$file}};

   Instead of just as a single concatenated string, as is done now:

        main::output @{$buf{$file}};

   Right now, the `foreach` approach doesn't work, as the client only
   `sysread()` a single chunk (1024 * 1024 bytes). But with a change in
   protocol, the client could do repeated reads until eof is reached.
** TODO `rong cat` -- Output files without final newline
   Doing `rong cat` respect any lack of a newline at the end of the file. That
   is, if a file is loaded, then outputted by means of `rong cat`, the
   outputted text should be identical to the original file.
** TODO `rong help` -- Detailed help info
   The detailed help info should provide the same info about the commands as is
   available from the command line using the `--help` option. (In fact, the
   `--help` option should fetch *its* help info from the server process, so as
   to make the client server-version agnostic.)

   The help output is this mode should preferably be the same as with command
   line help, e.g. `rong help load` should show the same text as `help load` in
   REPL-mode, and `rong help` and `rong --help` should show the same as `help`
   in REPL mode.
* [0/5] Make sure the sockets are used correctly
  Read up on sockets: https://docstore.mik.ua/orelly/perl4/cook/ch17_04.htm
** TODO Overview
   Many of the syscalls used for sockets have very cursory descriptions in
   `perlfunc` but are more thoroughly described in individual manpages: `recv`,
   `send` etc.

   Sockets are subject to both `stdio` buffering (which can be turned off with
   `$fh->autoflush(1)` -- which is needed when using a line-based protocol) and
   buffering at the operating system level (which, for TCP-sockets, can be
   disabled with the socket option TCP_NODELAY -- though this should only be
   done for applications that send real-time data, such as mouse movements or
   individual key presses).

   There are two types of sockets (Rong uses a streaming socket).

   + Streams (TCP-like)
     - Use file functions (except `seek` and `sysseek`).

   + Datagram (UDP-like)
     - Use `send()` and `recv()`.
 
** TODO Are credentials needed, or is socket file access enough?
** TODO How send byte-by-byte real-time data through socket? (for interactive mode)
** TODO How make client detect when server disappear? (to abort immediately)
   Source from: https://www.perlmonks.org/?node_id=11106953
   Here the client have a 2 second timeout, and disconnects if server does not
   respond within that time frame. This is probably not the method to use.

       #!/usr/bin/perl
       use strict;
       use warnings;
       use IO::Socket::UNIX;
       use constant SOCKET => 'test_socket.sock';
       my $mode = shift or die "Specify a mode\n";
       if ($mode eq 'server') {
           my $server = IO::Socket::UNIX->new(
               Type    => SOCK_STREAM,
               Local   => SOCKET,
               Listen  => 1,
               Timeout => 2,
           ) or die $!;
           while (my $conn = $server->accept()) {
               my $name = <$conn>;
               print {$conn} "Hello $name";
               close $conn;
           }
           print 'Timed out', "\n";
       }
       elsif ($mode eq 'client') {
           my $client = IO::Socket::UNIX->new(
               Type    => SOCK_STREAM,
               Peer    => SOCKET,
           ) or die $!;
           print {$client} 'John', "\n";
           print "Got reponse: ", scalar <$client>;
           close $client;
       }
       else {
           die "Unsupported mode: $mode\n";
       }
 
* [0/8] Protocol
** TODO Format: Raw mode? (for visual editor clients)
   Telnet protocol apparently have a line-based and a raw mode. How does that
   work?
** TODO Selection commands
** TODO Cursor move commands
** TODO Text insertion
** TODO Text deletion
** TODO Server pushes (client should be able to subscribe to events)
   This needs to be specified on a file level. Also, a client that isn't
   displaying a certain file should be able to unsubscribe, then resubscribe
   and ask for updates when a user starts editing that file again.
** TODO Separate protocol logic from server specifics
   The client and server skeleton logic should be in a separate module, and the
   specifics should be separated out into its own module.
* [0/4] Change-based Load/save
** TODO Implement file fingerprinting
   When loading a file ctime and a file fingerprint should also be remembered,
   then used for intelligently deciding when to save, or reload a file.
** TODO `rong load` -- Reload if file has changed (and buffer hasn't)
   When doing `rong load FILE` on an already loaded file, don't display error
   message:

       rong: Command 'load': File already loaded

   But instead check to see if file has been modified on disk, and if it has
   reload it.

   This should use fingerprinting, but do a checksum if fingerprint fails. That
   is, if file is identical to existing one, it should *never* be reloaded.
   (Instead a message should be given to the user.)
** TODO `rong save` -- Save if buffer has changed (but file hasn't)
   This should use fingerprinting, but do a checksum if fingerprint fails. That
   is, if file is identical to existing one, it should *never* be saved again.
   (Instead a message should be given to the user.)
* [6/10] Improve error messages & help
** DONE Fix faulty error messages (`__DIE__` hook double rewrite)
   CLOSED: [2024-01-18 Thu 22:17]
   Giving incorrect args to a command inserts 'rong:' twice in the error
   output. Fix this:

       $ rong list BLA
       rong list BLA: rong: No args allowed

   Was the result of a `$SIG{__DIE__}` hook being invoked inside an `eval { }`
   block.
** DONE Better sigdie handling
   CLOSED: [2024-01-19 Fri 19:46]
   Instead of having to `local $SIG{__DIE__} = 'DEFAULT'` inside of each eval
   block, the sigdie handler should detect that it was called from inside an
   eval, and not do it's usual error message rewriting.

   It was surprisingly hard to find a good description of how to avoid this,
   but I finally found it, hidden away in the perlfunc manpage (under the
   description of `die` function). Rather than giving a full code example, the
   manpage simply states that one should add the line `die @_ if $^S;` as the
   first line of any `$SIG{__DIE__}` handler.

   While searching for a way to do this I found the special Perl variable
   `$^S`, but had a hard time finding any more info since special characters
   aren't very googlable. I did find the following pages helpful though:

     + [[https://www.perlmonks.org/?node_id=51097][Perl's Warn and Die Signals (on Perlmonks)]]
     + [[https://www.perlmonks.org/?node_id=42411][SIGDIE (on Perlmonks)]]
     + perlfunc manpage (at end of description for `die`)
     + perlvar manpage (both under `%SIG` and `$^S`)
 
** DONE Sigdie handling should be setup at beginning of main
   CLOSED: [2024-01-19 Fri 20:14]
** DONE Make error messages more user friendly
   CLOSED: [2024-01-20 Sat 08:15]
   When invoking command from the command line, like so

       $ rong list osuh
       rong list osuh: No args allowed

   The error message should more similar to when an incorrect option was given:

       $ rong --osuhou
       rong: Unrecognized option '--osuhou'
       Try 'rong help' for more information.

   Something more like this:

       $ rong list osuh
       rong list "osuh": No args allowed
       Try 'rong help list' for more information.
 
** DONE More pedagogical server greeting
   CLOSED: [2024-01-30 Tue 11:31]
   When user connect in REPL mode, the server greeting should indicate that ^D
   is used to quit, and that `help` can be used for additional info.
** DONE Make client server-version agnostic
   CLOSED: [2024-02-02 Fri 14:11]
   The client needs a list of available commands from the server in order to
   parse the command line. To decouple the client and server completely, the
   client should ask the server for the available commands and use this info to
   parse the command line.

   There's gonna be a variable number of arguments for different server
   commands. Some will only ever take one arg ('load', 'save' etc.) some zero
   or one ('cd'), some two ('mv', 'cp' -- moar?).

   Rather than doing complicated tricks here, just give the entire command line
   to the server (minus any leading options intended for the Rong client), and
   let the server deal with it, returning any appropriate errors.
** TODO Fetch help info from server
   The command information should be read from the server, so that the REPL
   will show the same help info as the command line client.
** TODO Option `--help` and command `help` should give same output
   When this is done the "Try 'rong --help' for more information." should say
   `rong help` and `rong help COMMAND` rather than the current `rong --help`.
** TODO Failure when loading a symlink
   When attempting to load a symlinked file that points to a file that is
   already loaded, the error message isn't very helpful. Look at the following:

       $ rong
       README.txt
       $ ls -h le
       lrwxrwxrwx 1 zrajm zrajm 9 2024-01-17 18:46 le -> README.md
       $ rong le
       rong load le: File already loaded

   The error message should include that Rong attempted to load.
** TODO Error messages from `repl` and other subcommands should look the same
   Currently there's a difference in error messages between client-only
   commands (only `repl` at this point in time), and server commands. These
   should look the same:

       $ rong repl ga
       rong: No args allowed
       Try 'rong --help' for more information.

   (The above is missing the full `rong repl` command in the error message.)

       $ rong list ga
       rong list ga: No args allowed
 
* TODO Accept standard server signals (SIGHUP, SIGINT etc)
  Resist SIGTERM! This is so that `pkill rong` kills client processes but not
  the server.

  From: https://docstore.mik.ua/orelly/perl/cookbook/ch16_01.htm

  SIGINT: is normally triggered by Ctrl-C. This requests that a process
    interrupt what it's doing. Simple programs like filters usually just die,
    but more important ones like shells, editors, or FTP programs usually use
    SIGINT to stop long-running operations so you can tell them to do something
    else.

  SIGQUIT: is also normally generated by a terminal, usually Ctrl-\. Its
    default behavior is to generate a core dump.

  SIGTERM: is sent by the kill shell command when no signal name is explicitly
    given. Think of it as a polite request for a process to die. SIGUSR1 and

  SIGUSR2: are never caused by system events, so user applications can safely
    use them for their own purposes.

  SIGPIPE: is sent by the kernel when your process tries to write to a pipe or
    socket when the process on the other end has closed its connection, usually
    because it no longer exists.

  SIGALRM: is sent when the timer set by the alarm function expires, as
    described in Recipe 16.21.

  SIGHUP: is sent to a process when its controlling terminal gets a hang-up
    (e.g., the modem lost its carrier), but it also often indicates that a
    program should restart or reread its configuration.

  SIGCHLD: is probably the most important signal when it comes to low-level
    systems programming. The system sends your process a SIGCHLD when one of
    its child processes stops running - or, more likely, when that child exits.
    See Recipe 16.19 for more on SIGCHLD.
* TODO `rong list` option to display absolute paths
* TODO All clients should die (immediately) if server dies
  Maybe temporarily add a die command to test this on the server side?

  If not doing `chomp($x)` after reading STDIN in REPL-mode, and calling
  `deserialize()` before the `eval { }` in `invoke()` the first command in
  REPL-mode will work, but the second will crash the server.

  Is using $fh->connected to verify that we're still connected the way to do
  it?
* TODO Make sure error message is intelligible if initial `cd` fails
  This will happen if the current directory doesn't exist when starting rong.
* TODO Command to check if server is running (without starting it)
* TODO Escaping should use same schema as shell or 'ls' command
  To make it make when using `rong list`.
* [0/8] FAR-FLUNG FUTURE FEATURES
** TODO If socket file is deleted, should server re-create it(?)
** TODO Use `shutdown()` to close socket?
   https://docstore.mik.ua/orelly/perl/cookbook/ch17_10.htm
** TODO On startup make sure any existing tempdir is chmod 0700
   Function: create_tempdir() -- Easiest is maybe to just 'chmod 0700' the
   directory if it exists on startup?
** TODO Use Perl -T (taint flag) for the server
    Manpage perlipc says this is a good idea:

    > You should use the `-T` flag to enable taint checking (see perlsec) even
    > if we aren't running setuid() or setgid(). This is always a good idea for
    > servers or any program run on behalf of someone else (like CGI scripts),
    > because it lessens the chances that people from the outside will be able
    > to compromise your system.
 
** TODO Client authentication
   Is being able to connect to the socket enough of an authentication?
** TODO Keep track of open connections, die when last has exited(?)
   But don't die before first client has connected.
** TODO Change client directory to root
   Clients should remember their starting directory, but change dir to '/' so
   that their original dir can be unmounted etc.
** TODO Make client server-version agnostic
   The client needs a list of available commands from the server in order to
   parse the command line. To decouple the client and server completely, the
   client should ask the server for the available commands and use this info to
   parse the command line.

   There's gonna be a variable number of arguments for different server
   commands. Some will only ever take one arg ('load', 'save' etc.) some zero
   or one ('cd'), some two ('mv', 'cp' -- moar?).

   Maybe the server greeting could contain the relevant help info? For example
   something like (sadly, this would make the greeting longer that one line):

       OK rong 0.0.42 /tmp/rong-100/default 0(exit halt help list cd) 1(cd
           cat kill load save) 2(mv cp)
 
* [0/2] TESTS
** TODO Use the modulino pattern to make program testable
** TODO Resolving absolute paths
   Then resolving any `/../` parts of a path, there's a corner case involving
   symlinks that needs to be considered. Here a description from the manpage
   File::Spec(3perl)

       Note that this does *not* collapse `x/../y` sections into `y`. This is
       by design. If `/foo` on your system is a symlink to `/bar/baz`, then
       `/foo/../quux` is actually `/bar/quux`, not `/quux` as a naive
       `../`-removal would give you. If you want to do this kind of processing,
       you probably want "Cwd"'s "realpath()" function to actually traverse the
       filesystem cleaning up paths like this.
 
* [eof]
