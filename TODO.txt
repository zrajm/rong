-*- org -*-

* [1/11] Protocol
** DONE Format: The basics
   CLOSED: [2024-01-04 Thu 10:43]
   + Server starts when client connect, sends `OK rong <VERSION> <SOCKET>`
   + All server responses is single line, starting with 'OK' or 'ERR'
** TODO Use sysread for sockets?
   See also: https://stackoverflow.com/a/5600853/351162 (diff <>, sysread, rect)
   Raw fileread: https://www.perlmonks.org/?node_id=1195588

   On nonblocking sockets and ->connected():
   https://www.ralph-schuster.eu/2015/06/19/nonblocking-sockets-and-perls-netdaemon/

   Webserver with Perl:
   https://redirect.cs.umbc.edu/courses/331/fall12/notes/perl/aWebserverWithPerl.html

   Switched to using recv() for the sockets, but it'd be nicer to use something
   that can be used on both STDIN and socket, to simplify the client REPL-loop.

   Sysread doesn't allow Unicode, but if set up so that just raw bytes are
   shuffled over the socket that shouldn't matter. (The benefit of this is to
   avoid hangs.)
** TODO Format: Multi-line server response? (for interactive `help` command)
   I want the server to be able to talk to a user for exploratory purposes.
   Thus there should always be REPL-mode, and it should have a `help` command.
   For this to work server needs to be able to respond with multi-line output,
   what should this look like? (How do other protocols do this?)

   The help output is this mode should preferably be the same as with command
   line help, e.g. `rong help load` should show the same text as `help load` in
   REPL-mode.
** TODO Format: Raw mode? (for visual editor clients)
   Telnet protocol apparently have a line-based and a raw mode. How does that
   work?
** TODO Selection commands
** TODO Cursor move commands
** TODO Text insertion
** TODO Text deletion
** TODO Server pushes (client should be able to subscribe to events)
   This needs to be specified on a file level. Also, a client that isn't
   displaying a certain file should be able to unsubscribe, then resubscribe
   and ask for updates when a user starts editing that file again.
** TODO Separate protocol logic from server specifics
   The client and server skeleton logic should be in a separate module, and the
   specifics should be separated out into its own module.
** TODO Use File::Spec for filenames and path handling(?)
* [12/19] Server
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :END:
** DONE Listen to multiple incoming connections (without threading)
   CLOSED: [2023-12-31 Sun 15:49]
   This is done using IO::Select, and the code was adapted from final example
   code on the IO::Select manpage.
** [6/6] Daemonize server completely
   From: https://theworld.com/~swmcd/steven/tech/daemon.html
   (Though I added wait() to reap the intermediate process.)

        use POSIX 'setsid';
        sub daemonize {
            fork and do { wait; return };
            POSIX::setsid();
            fork and exit;
            umask 0;
            chdir '/';
            close STDIN;
            close STDOUT;
            close STDERR;
        }
 
*** DONE 1. Fork intermediate process
    CLOSED: [2024-01-01 Mon 09:13]
    `fork` -- The first fork allows the child to run the daemon while the
    parent continues execution, or exits. In addition, it ensures that the
    child is not a process group leader, so that the following `setsid()` call
    will succeed.

    I also added a `wait` call in the invoking client process, so as to reap
    the intermediate process and never leave a zombie process in the process
    table.
*** DONE 2. Create new process session
    CLOSED: [2024-01-01 Mon 09:13]
    `setsid` -- This is how we lose our controlling terminal. `setsid` makes
    our process the session leader of a new session, and when a new session is
    created, the session leader has no controlling terminal.
*** DONE 3. Fork server process
    CLOSED: [2024-01-01 Mon 09:13]
    `fork` -- The leader of a new session has no controlling terminal, but
    it could acquire one, for example, by opening `/dev/tty` or the like. To
    ensure that this doesn't happen, we fork again.

    After the second fork, the child is not the session leader (the parent is
    the session leader) and only a session leader can acquire a controlling
    terminal. Of course, the child could become a session leader by executing
    `setsid` again, but presumably anyone who does that knows what they are
    doing.
*** DONE 4. Reset umask
    CLOSED: [2024-01-01 Mon 09:13]
    `umask 0` -- `umask` is inherited across `fork` and `exec`, and we don't
    want our daemon to be limited by whatever `umask` it happens to inherit
    from its parent.
*** DONE 5. Change dir to '/'
    CLOSED: [2024-01-01 Mon 09:13]
    `chdir '/'` -- The current working directory is inherited across `fork` and
    `exec`. If we leave the daemon running in some random directory, then the
    file system that contains that directory can never be `umounted`, and
    someone might want to.
*** DONE 6. Close standard streams
    CLOSED: [2024-01-01 Mon 09:13]
    `close` -- Even though the daemon has no controlling terminal, it may still
    have open file descriptors on a terminal, and these can cause trouble. For
    reliable operation, close the system file descriptors.
** DONE Simple logging to tempdir
   CLOSED: [2024-01-01 Mon 11:02]
   Store a log as a buffer? Log to a file? Write status stuff into
   notifications? Have a client log mode, so that all error messages are sent
   to all log-receiving clients?
** DONE Git commit hook to validate $VERSION before commit
   CLOSED: [2024-01-01 Mon 15:55]
** DONE Redirect server STDERR to logfile
   CLOSED: [2024-01-04 Thu 09:42]
   So that error messages wind up there. (STDOUT is not important, since the
   logfile filehandle is selected and the output of print() and friends
   therefore already winds up in the logfile.)

   Took the approach exemplified by the following snippet in the perlipc(1)
   manpage (except that I'm closing STDIN rather than reading from /dev/null).

       sub daemonize {
           chdir("/")                     || die "can't chdir to /: $!";
           open(STDIN,  "<", "/dev/null") || die "can't read /dev/null: $!";
           open(STDOUT, ">", "/dev/null") || die "can't write /dev/null: $!";
           defined(my $pid = fork())      || die "can't fork: $!";
           exit if $pid;              # non-zero now means I am the parent
           (setsid() != -1)           || die "Can't start a new session: $!";
           open(STDERR, ">&", STDOUT) || die "can't dup stdout: $!";
       }
 
** DONE Server greeting
   CLOSED: [2024-01-04 Thu 10:43]
   Upon connecting the server should send a greeting containing server name and
   version number. E.g. `OK rong 0.0.10 /tmp/rong-1000/default`.
** DONE Escape filename when talking client<->server
   CLOSED: [2024-01-05 Fri 18:43]
** TODO Keep track of client-specific data
   E.g. login info, maybe more later.
** TODO On startup make sure any already existing tempdir is chmod 0700
   Function: create_tempdir() -- Easiest is maybe to just 'chmod 0700' the
   directory if it exists on startup?
** TODO Accept standard signals for reload/restart (SIGHUP, SIGINT etc.)
   Resist SIGTERM! This is so that `pkill rong` kills client processes but not
   the server.

   From: https://docstore.mik.ua/orelly/perl/cookbook/ch16_01.htm

   SIGINT: is normally triggered by Ctrl-C. This requests that a process
     interrupt what it's doing. Simple programs like filters usually just die,
     but more important ones like shells, editors, or FTP programs usually use
     SIGINT to stop long-running operations so you can tell them to do something
     else.

   SIGQUIT: is also normally generated by a terminal, usually Ctrl-\. Its
     default behavior is to generate a core dump.

   SIGTERM: is sent by the kill shell command when no signal name is explicitly
     given. Think of it as a polite request for a process to die. SIGUSR1 and

   SIGUSR2: are never caused by system events, so user applications can safely
     use them for their own purposes.

   SIGPIPE: is sent by the kernel when your process tries to write to a pipe or
     socket when the process on the other end has closed its connection, usually
     because it no longer exists.

   SIGALRM: is sent when the timer set by the alarm function expires, as
     described in Recipe 16.21.

   SIGHUP: is sent to a process when its controlling terminal gets a hang-up
     (e.g., the modem lost its carrier), but it also often indicates that a
     program should restart or reread its configuration.

   SIGCHLD: is probably the most important signal when it comes to low-level
     systems programming. The system sends your process a SIGCHLD when one of
     its child processes stops running - or, more likely, when that child exits.
     See Recipe 16.19 for more on SIGCHLD.
** [0/4] FAR-FLUNG FUTURE FEATURES
*** TODO Use Perl -T (taint flag) for the server
    Manpage perlipc says this is a good idea:

    > You should use the `-T` flag to enable taint checking (see perlsec) even
    > if we aren't running setuid() or setgid(). This is always a good idea for
    > servers or any program run on behalf of someone else (like CGI scripts),
    > because it lessens the chances that people from the outside will be able
    > to compromise your system.
 
*** TODO Client authentication
    Is being able to connect to the socket enough of an authentication?
*** TODO Keep track of open connections, die when last has exited(?)
    But don't die before first client has connected.
*** TODO Client-server connection should agree on version
    Server should respond to the client with version, and the client should
    check that the version isn't too far off into the future. (I.e. only the
    patch number is allowed to be different from the client's version number.)

    Is there a way to restart the server if versions if needed? (That is, keep
    state, but reload the server's code?)
* [3/6] Client
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:
** DONE Read from both STDIN and server at same time
   CLOSED: [2023-12-31 Sun 15:49]
   This is done using IO::Select.
** DONE Verify server greeting when connecting
   CLOSED: [2024-01-05 Fri 00:30]
   When a client connects to the server it should verify the returned greeting
   using something like:

       # Verify server greeting.
       if ($sockets->can_read) {
           defined(my $greeting = <$server>)
               or die "Cannot read server greeting: $!\n";
          die "Cannot understand server greeting\n",
              "    expected: OK rong #.#.# $socket\n",
              "    but got : $greeting"
              unless $greeting =~ /^OK rong \d+\.\d+\.\d+ \Q$socket\E$/;
       }
 
** DONE Send single server commands
   CLOSED: [2024-01-05 Fri 04:18]
   The client should be able to connect, some specified command(s) then
   disconnect, rather than always going into an interactive REPL-mode.
** TODO Change directory to root
   Clients should remember their starting directory, but change dir to '/' so
   that their original dir can be unmounted etc.
** TODO Should shutdown() be used when closing socket?
   https://docstore.mik.ua/orelly/perl/cookbook/ch17_10.htm
** [0/2] FAR-FLUNG FUTURE FEATURES
*** TODO Make client server-version agnostic(?)
    The client should query the server for allowed syntax for each server
    command, then use that to check the validity of the command line options.

    There's gonna be a variable number of arguments for different server
    commands. Some will only ever take one arg ('load', 'save' etc.) some zero
    or one ('cd'), some two ('mv', 'cp' -- moar?).

    Maybe the server greeting could contain the relevant help info? For example
    something like (sadly, this would make the greeting longer that one line):

        OK rong 0.0.42 /tmp/rong-100/default 0(exit halt help list cd) 1(cd
            cat kill load save) 2(mv cp)
 
* [6/6] Basic subcommands
  Server commands only take zero or one arg. Client execute multi-arg commands
  as one command for each arg (resulting in one 'OK' or 'ERR' for each arg).
** DONE `rong load FILE...`
   CLOSED: [2024-01-05 Fri 15:21]
** DONE `rong list`
   CLOSED: [2024-01-06 Sat 12:55]
** DONE `rong kill FILE...`
   CLOSED: [2024-01-08 Mon 15:01]
** DONE `rong help`
   CLOSED: [2024-01-10 Wed 00:55]
** DONE `rong save FILE`
   CLOSED: [2024-01-10 Wed 01:04]
** DONE `rong cat FILE`
   CLOSED: [2024-01-10 Wed 01:08]
* [13/13] `rong cd DIR` & relative filenames
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:
  Relative filenames should be used everywhere. Hmm? Should we use the clients
  path as base? Should filtering based on client's path be used instead of
  something session-y as well?

  File::Spec is a core module. Use that!
** DONE Use absolute paths internally
   CLOSED: [2024-01-10 Wed 19:29]
*** DONE Handle paths better
    The client cannot just always send full paths as args for each command (this
    would make REPL-mode unpleasant to use).

    How to do this? Deal with it on the client side? Or have client send it's
    current directory to the server as it is connecting?
*** DONE `load FILE`
*** DONE `list`
*** DONE `kill FILE`
*** DONE `save FILE`
*** DONE `cat FILE`
** DONE Connection specific options
   CLOSED: [2024-01-12 Fri 19:25]
   These are some config specific to a client-server connection. They are
   initialized when the client connects to the server, and forgotten again when
   a client disconnects. The only setting right now is the current directory of
   the client.

   In interactive mode the user is now able to `cd` somewhere, then have the
   `list` of files be relative to that current directory.
** WONT Better client session ID
   Not really needed, I think? `fileno()` should result in a unique number for
   each open file in the server, regardless of filename. The only benefit of
   using something more elaborate would be a lessened risk of accidentally
   sharing info with the next client to connect (which could happen if the
   previous connection failed to do its cleanup).

   Client session ID should be unique even across multiple sockets (for when we
   start doing that).
** [2/2] Client should always send `cd` command when connecting
   For single commands, issue a `cd $PWD` command before invoking the
   user-requested command(s).
*** DONE Always send initial `cd` from client
    CLOSED: [2024-01-14 Sun 00:03]
*** DONE Suppress output from initial `cd` command
    CLOSED: [2024-01-14 Sun 02:40]
** DONE Use `Cwd::getcwd()` instead of `Cwd:cwd()`
   CLOSED: [2024-01-16 Tue 18:34]
   `Cwd:cwd()` gives a weird error message when invoked from inside a
   non-existing directory:

      /bin/pwd: couldn't find directory entry in ‘..’ with matching i-node

   Also, using `Cwd::cwd()` does not resolve uniquely (since symlinks in the
   path are not resolved). So therefore, use `Cwd::getcwd()` (which does
   resolve all symlinks) instead.
** DONE Handle `~[username]` directories
   CLOSED: [2024-01-17 Wed 05:09]
* DONE `rong list` with no files loaded shouldn't display blank line
  CLOSED: [2024-01-17 Wed 03:26]
* DONE Fix `abspath()`
  CLOSED: [2024-01-17 Wed 05:09]
  Loading a file with a path like `foo/../lala` should result in the loaded
  file having a name which does not include the `..` component.
* TODO `rong list` when current dir is unknown -- use absolute paths
  When path is '/' or undef, display absolute paths.
* TODO Server should log when it starts
* TODO Server should log when it exits/dies
  An `END` block inside the Rong package, should work. But it doesn't fire on
  SIGINT (unless there's a trap, possibly?).

      END { warn "(server exited)\n" unless -t STDERR }

* TODO `rong list` option to display absolute paths
* TODO Client should die (immediately) if server dies
  Maybe temporarily add a die command to test this on the server side?

  If not doing `chomp($x)` after reading STDIN in REPL-mode, and calling
  `deserialize()` before the `eval { }` in `invoke()` the first command in
  REPL-mode will work, but the second will crash the server.

  Is using $fh->connected to verify that we're still connected the way to do
  it?
* TODO create_tmpdir() should use File::Spec->tmpdir()
* TODO Make sure error message is intelligible if initial `cd` fails
  This will happen if the current directory doesn't exist when starting rong.
* TODO Empty arg to escape() should return ""
* TODO Command to check if server is running (without starting it)
* [0/12] Improve subcommands
** TODO Subcommand functions should not be in hash
** TODO `rong` (without args) should start server + list buffers
   This should start the daemon process and then immediately exist the client.
   (Under normal circumstances this command is not needed since a server if it
   isn't already running, when starting a client will start it.)

   Note: In the future we might want a way to name the server socket, so that
   user may run multiple daemons at the same time.
** TODO `rong repl`
   There should be a user greeting, with listing of commands also telling that
   ^C or ^D exists.
** TODO `rong cd` should allow symlink(s) in path
   When `foo` is symlink to `bar/baz` then cd `foo` should set the current dir
   to `foo` (NOT `bar/baz`)
** TODO `rong load` -- Handle read errors
   Should any catch any errors gotten while reading (in `<$fh>` statement) too.
** TODO `rong save` -- Handle write errors
   Should any catch errors gotten while writing (in `print` statement) too.
** TODO `rong save` -- Make atomic
** TODO `rong cat` -- with no trailing newline
   If the file doesn't end in a newline, then newline should be added. This
   requires different schema for the OK/ERR message, as the OK/ERR no longer
   will be at the end of the last line. How do other protocols handle this?
** TODO `rong mv`
** TODO `rong cp`
** TODO Failing a command should result in non-zero exit status
** TODO File fingerprinting & checksumming
*** TODO `rong load` -- Avoid useless reloads
    This should use fingerprinting, but do a checksum if fingerprint fails.
    That is, if file is identical to existing one, it should *never* be
    reloaded. (Instead a message should be given to the user.)
*** TODO `rong save` -- Avoid useless resaves
    This should use fingerprinting, but do a checksum if fingerprint fails.
    That is, if file is identical to existing one, it should *never* be
    saved again. (Instead a message should be given to the user.)
* TODO Escaping should use same schema as shell or 'ls' command
  To make it make when using `rong list`.
* [0/1] TESTS
** TODO Resolving absolute paths
   Then resolving any `/../` parts of a path, there's a corner case involving
   symlinks that needs to be considered. Here a description from the manpage
   File::Spec(3perl)

       Note that this does *not* collapse `x/../y` sections into `y`. This is
       by design. If `/foo` on your system is a symlink to `/bar/baz`, then
       `/foo/../quux` is actually `/bar/quux`, not `/quux` as a naive
       `../`-removal would give you. If you want to do this kind of processing,
       you probably want "Cwd"'s "realpath()" function to actually traverse the
       filesystem cleaning up paths like this.
 
* [eof]
