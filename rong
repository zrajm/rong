#!/usr/bin/env perl
# Copyright (C) 2023 zrajm <rong@zrajm.org>
# License: GPLv2 [https://gnu.org/licenses/gpl-2.0.txt]

# https://perl.com/pub/2012/04/perlunicook-standard-preamble.html
use utf8;      # so literals and identifiers can be in UTF-8
use v5.12;     # or later to get "unicode_strings" feature
use strict;    # quote strings, declare variables
use warnings;  # on by default
use warnings  qw(FATAL utf8);    # fatalize encoding glitches
use open      qw(:std :utf8);    # undeclared streams in UTF-8
use charnames qw(:full :short);  # unneeded in v5.16

use IO::Socket;
use IO::Select;
use POSIX;

###############################################################################
# Functions

# sub read_file {
#     my ($file) = @_;
#     open(my $in, '<', $file) or die "Cannot open file '$file' for reading\n";
#     return wantarray ? <$in> : join('', <$in>);
# }

# sub write_file {
#     my ($file, $data, $fh) = @_;
#     open($fh, '>', $file) or die "Cannot open file '$file' for writing: $!\n";
#     print $fh $data;
#     close($fh) or die "Cannot close file '$file' after writing: $!\n";
# }

# Usage: create_tempdir()
#
# Creates a run directory for the Rong server and clients. The directory is
# called '<TEMPDIR>/<PROGRAMNAME>-<USERID>' (usually '/tmp/rong-1000' but all
# parts can change depending on your $TEMPDIR variable, the name of the script
# and your user's numerical user id). The directory name is the same as Tmux.
sub create_tempdir {
    my $dir = sprintf '%s/%s-%s',
        ($ENV{TMPDIR} // '/tmp'),              # tempdir
        (split('/', $0))[-1],                  # program's basename
        $<;                                    # real user ID (number)
    mkdir($dir, 0700) or die "Cannot create tempdir '$dir': $!\n"
        unless -d $dir;
    return $dir;
}

sub start_server {
    my ($socket_path) = @_;

    # Create socket for listening to new clients (it's inherited by child
    # processes). This is done BEFORE forking avoid race where child tries to
    # connect and listening socket isn't yet there.
    my $socket_fh = listening_socket($socket_path)
        or die "Cannot create server's listening socket: $!";

    # Start intermediate process (session leader in new session).
    defined(my $inter_pid = fork) or die "Cannot fork intermediate: $!\n";
    if ($inter_pid) {                          # in client:
        close $socket_fh;
        wait;                                  #   reap intermediate process
        return;
    }
    POSIX::setsid or die "Cannot make process session leader: $!";

    # Start server process.
    defined(my $server_pid = fork) or die "Cannot fork server: $!\n";
    if ($server_pid) {                         # in intermediate
        exit;
    }

    # I am now the server.
    umask(0) or die "Cannot change umask to '0': $!\n";
    chdir('/') or die "Cannot change directory to '/': $!\n";
    close STDIN;
    close STDOUT;
    close STDERR;
    $0 .= ' --daemon';                         # server process name
    server_main($socket_fh);
    exit 0;
}

# Used by client to connect to server.
sub connection_socket {
    my ($socket_path) = @_;
    my $fh = IO::Socket::UNIX->new(
        Type => SOCK_STREAM(),
        Peer => $socket_path,
    );
    $fh->autoflush(1) if $fh;
    return $fh;
}

# Used by server to listen for new client connections.
sub listening_socket {
    my ($socket_path) = @_;
    if (-e $socket_path) {
        -S $socket_path
            or die "Will not delete non-socket file '$socket_path'\n";
        unlink $socket_path
            or die "Cannot delete previous socket '$socket_path': $!\n";
    }
    my $fh = IO::Socket::UNIX->new(
        Listen => 1,
        Type => SOCK_STREAM(),
        Local => $socket_path,
    );
    $fh->autoflush(1) if $fh;
    return $fh;
}

sub server_main {
    my ($server) = @_;

    # Wait until there's input on any incoming connection.
    my $inputs = IO::Select->new($server);
    while (my @ready = $inputs->can_read) {
        foreach my $fh (@ready) {
            if ($fh == $server) {              # client connected
                print "(client connected)\n";
                my $new = $server->accept;
                $inputs->add($new) if $new;
                next;
            }
            my $line = <$fh>;
            if (not defined $line) {           # client disconnected
                print "(client disconnected)\n";
                $inputs->remove($fh);
                $fh->close;
                next;
            };
            chomp $line;
            print "(from client): $line";      # received input
            print $fh "received '$line'\n";
        }
    }
}

###############################################################################
# Main

my $tempdir = create_tempdir();
my $socket = "$tempdir/default";

# Connect to server.
my $server = connection_socket($socket);
if (not $server) {                             # failed to connect
    print "Starting server process\n";
    start_server($socket);                     #   start server
    $server = connection_socket($socket)       #   and try to connect again
        or die "Cannot connect to server\n";
} else {
    print "Server already running\n";
}

# Wait until there's input from either STDIN or $server.
print "[Connected to '$socket']\n";
my $inputs = IO::Select->new(\*STDIN, $server);
while (my @ready = $inputs->can_read) {
    foreach my $fh (@ready) {
        defined(my $x = <$fh>) or exit;    # exit on ^D
        if ($fh == $server) {
            print "(from server): $x";
        } else {
            print "(from STDIN): $x";
            print $server $x;
        }
    }
}

#[eof]
