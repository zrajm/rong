#!/usr/bin/env perl
# Copyright (C) 2023-2024 zrajm <rong@zrajm.org>
# License: GPLv2 [https://gnu.org/licenses/gpl-2.0.txt]

# https://perl.com/pub/2012/04/perlunicook-standard-preamble.html
use utf8;      # so literals and identifiers can be in UTF-8
use v5.12;     # or later to get "unicode_strings" feature
use strict;    # quote strings, declare variables
use warnings;  # on by default
use warnings  qw(FATAL utf8);    # fatalize encoding glitches
use open      qw(:std :utf8);    # undeclared streams in UTF-8
use charnames qw(:full :short);  # unneeded in v5.16

use IO::Socket;
use IO::Select;
use POSIX;
use File::Spec;
use Cwd;

our $AUTHOR='zrajm <rong@zrajm.org>';
our $VERSION='0.0.42';                         # https://semver.org/
our $VERSION_DATE='20 January 2024';
our $CREATED_DATE='28 December 2023'; # never change this!
our $USAGE = <<'USAGE_END';
Usage: rong [OPTION]... [COMMAND [ARG]...|FILE...]
A daemonic headless text editor.

Options:
  -h, --help      Display this help and exit
  -V, --version   Output version information and exit

Commands:
  cat FILE...     Output FILE(s) on standard output
  cd DIR          Change directory used for relative filenames
  help            Display list of commands
  kill FILE...    Unload FILE(s)
  [list]          List loaded files (default if no FILE given)
  [load] FILE...  Load FILE(s) (default if FILE(s) are given)
  repl            Interactively talk to Rong server directly
  save FILE...    Save FILE(s)

If neither COMMAND nor FILE(s) are given, `list` is assumed. If FILE(s) are
specified but COMMAND is not, then `load` is assumed.
USAGE_END

###############################################################################
# Functions

sub help { print $USAGE; exit 0; }
sub version {
    my $program    = (File::Spec->splitpath(__FILE__))[2];
    my ($years)    = $CREATED_DATE =~ m#(\d{4})#;
    my ($end_year) = $VERSION_DATE =~ m#(\d{4})#;
    $years .= "-$end_year" unless $years eq $end_year;
    print(
        "$program (zrajm utils) $VERSION ($VERSION_DATE)\n",
        "Copyright (C) $years $AUTHOR\n",
        "License: GNU GPLv2 <https://gnu.org/licenses/gpl-2.0.txt>.\n",
        "This is free software: You are free to change and redistribute it.\n");
    exit 0;
}

# Usage: create_tempdir()
#
# Creates a run directory for the Rong server and clients. The directory is
# called '<TEMPDIR>/<PROGRAMNAME>-<USERID>' (usually '/tmp/rong-1000' but all
# parts can change depending on your $TEMPDIR variable, the name of the script
# and your user's numerical user id). The directory name is the same as Tmux.
sub create_tempdir {
    my $program = (File::Spec->splitpath(__FILE__))[2];
    my $dir = File::Spec->join(File::Spec->tmpdir(), "$program-$<");
    mkdir($dir, 0700) or die "Cannot create tempdir '$dir': $!\n"
        unless -d $dir;
    return $dir;
}

# Used by client to connect to server.
sub connection_socket {
    my ($socket_path) = @_;
    my $fh = IO::Socket::UNIX->new(
        Type => SOCK_STREAM(),
        Peer => $socket_path,
    );
    $fh->autoflush(1) if $fh;
    return $fh;
}

# Used by server to listen for new client connections.
sub listening_socket {
    my ($socket_path) = @_;
    if (-e $socket_path) {
        -S $socket_path
            or die "Will not delete non-socket file '$socket_path'\n";
        unlink $socket_path
            or die "Cannot delete previous socket '$socket_path': $!\n";
    }
    my $fh = IO::Socket::UNIX->new(
        Listen => 1,
        Type => SOCK_STREAM(),
        Local => $socket_path,
    );
    $fh->autoflush(1) if $fh;
    return $fh;
}

sub start_server {
    my ($socket_path, $logfile) = @_;

    # If server is already running, return connection to that.
    if (my $clientfh = connection_socket($socket_path)) {
        return $clientfh;
    }

    # Create server's listening socket to which new clients connect (it's
    # inherited by child processes). Done BEFORE forking avoid race condition
    # where child tries to connect and listening socket isn't yet there.
    my $listenfh = listening_socket($socket_path)
        or die("Cannot create socket '$socket_path': $IO::Socket::errstr\n");

    # Start intermediate process (session leader in new session).
    defined(my $inter_pid = fork) or die "Cannot fork intermediate: $!\n";
    if ($inter_pid == 0) {                     # in intermediate
        (POSIX::setsid != -1) or die "Cannot start new session: $!";
        # Start server process.
        defined(my $server_pid = fork) or die "Cannot fork server: $!\n";
        if ($server_pid == 0) {                # in server
            $0 .= ' --daemon';                 #   server process name
            my $root = File::Spec->rootdir();
            umask(0) or die "Cannot change umask to '0': $!\n";
            chdir($root) or die "Cannot change dir to '$root': $!\n";
            close STDOUT;
            open(STDERR, '>>', $logfile)
                or die "Cannot open logfile '$logfile': $!\n";
            close STDIN;
            server_main($listenfh, $socket_path);# never returns
            exit 0;
        }
        exit 0;
    }

    # Client process (original process).
    close $listenfh;                           # close listening socket
    wait;                                      # reap intermediate process
    return connection_socket($socket_path)     # connect to new server
}

{
    package rong;
    use sigtrap qw/handler exithandler normal-signals/;

    sub exithandler {
        warn "(server exited)\n" unless -t STDERR;
    }

    ###########################################################################
    ## Internal functions, called inside eval, use die() to indicate error

    sub load_file {
        my ($file) = @_;
        die "Cannot load a directory\n" if -d $file;
        die "Cannot load a block device\n" if -b _;
        die "Cannot load a character device\n" if -c _;
        die "Cannot load a named pipe\n" if -p _;
        die "Cannot load a socket\n" if -S _;
        open(my $fh, '<', $file) or die "Cannot open file: $!\n";
        my @buf;
        until (eof $fh) {
            my $x = <$fh> // die "Cannot read file: $!\n";
            push(@buf, $x);
        }
        close($fh) or die "Cannot close file: $!\n";
        return \@buf;
    }

    sub save_file {
        my ($file, $data) = @_;
        open(my $fh, '>', $file) or die "Cannot open file: $!\n";
        print($fh @$data) or die "Cannot write file: $!\n";
        close($fh) or die "Cannot close file: $!\n";
    }

    sub abspath {
        my ($path, $base) = @_;
        $path =~ s#^~[^/]*# glob("'$&'") #e;
        $path = File::Spec->join($base, $path)
            unless File::Spec->file_name_is_absolute($path);
        $path = Cwd::realpath($path) or die "Cannot find absolute path: $!\n";
        return $path;
    }

    sub relpath {
        my ($path, $base) = @_;
        return $base eq File::Spec->rootdir()
            ? $path : File::Spec->abs2rel($path, $base);
    }

    # Here say() & print() goes to client; warn() goes to log; die() exits with
    # error message.
    my %buf;
    my %opt; # $opt{$id}{$property} where '$id' is a client connection id.

    sub cmd_cat {
        my ($id, $file) = @_;
        die "No file specified\n" unless $file;
        $file = abspath($file, $opt{$id}{pwd});
        die "No such file loaded\n" if not exists $buf{$file};
        print @{$buf{$file}};
    }

    sub cmd_cd {
        my ($id, $dir) = @_;
        if (defined $dir) {
            my $newdir = abspath($dir, $opt{$id}{pwd});
            die "Directory does not exist\n" unless -d $newdir;
            $opt{$id}{pwd} = $newdir;
        }
        say $opt{$id}{pwd};
    }

    sub cmd_help {
        my ($id, @arg) = @_;
        die "Too many arguments\n" if @arg;
        say join(' ', sort(subcommands()));
    }

    sub cmd_kill {
        my ($id, $file) = @_;
        die "No file specified\n" unless $file;
        $file = abspath($file, $opt{$id}{pwd});
        die "No such file loaded\n" if not exists $buf{$file};
        delete $buf{$file};
    }

    sub cmd_list {
        my ($id, @arg) = @_;
        die "Too many arguments\n" if @arg;
        print map {
            escape(relpath($_, $opt{$id}{pwd})) . "\n";
        } sort keys(%buf);
    }

    sub cmd_load {
        my ($id, $file) = @_;
        die "No file specified\n" unless $file;
        $file = abspath($file, $opt{$id}{pwd});
        die "File already loaded\n" if exists $buf{$file};
        $buf{$file} = load_file($file);
    }

    sub cmd_save {
        my ($id, $file) = @_;
        die "No file specified\n" unless $file;
        $file = abspath($file, $opt{$id}{pwd});
        die "No such file loaded\n" if not exists $buf{$file};
        save_file($file, $buf{$file});
    }

    # Note: escape() & serialize() are used externally (and must therefore not
    # die()), while unescape() and deserialize() are not (and may die()).
    sub deserialize {
        local ($_) = @_;
        my @x = m/\G( "(?:[^"\\]|\\.)*" |      # double quoted
                      '(?:[^'\\]|\\.)*' |      # single quoted
                      [^[:cntrl:][:space:]"']+ # other words
                  )(?:\h+|$)/gxc;
        die "Cannot deserialize string\n" if pos != length;
        return map { unescape($_) } @x;
    }
    sub unescape {
        local ($_) = @_;
        /^(["'])(.*)\1$/ and $_ = $2;
        s#\\([abefnrt\\\"']|x[0-9A-F]{2})# eval "\"$&\"" #ge;
        return $_;
    }

    ###########################################################################
    ## Called externally, must not die()

    sub serialize { join ' ', map { escape($_) } @_ }
    sub escape {
        local ($_) = @_;
        my %c = ("\a"=>'\a', "\b"=>'\b', "\e"=>'\e',  "\f"=>'\f', "\n"=>'\n',
                 "\r"=>'\r', "\t"=>'\t', "\\"=>'\\\\','"' =>'\"', "'" =>"\\'");
        return s# [[:cntrl:]\\"] # $c{$&} // sprintf('\\x%02X', ord $&) #gex
            || /^$/ || / / ? "\"$_\"" : $_;    # if empty or has space/escape
    }

    sub initialize {
        my ($id, $listenfile) = (@_);
        my $program = (File::Spec->splitpath(__FILE__))[2];
        $opt{$id} = { pwd => File::Spec->rootdir() };
        warn "(client $id connected, path '$opt{$id}{pwd}')\n";
        say "OK $program $VERSION $listenfile";
    }

    sub terminate {
        my ($id) = (@_);
        warn "(client $id disconnected, path '$opt{$id}{pwd}')\n";
        delete $opt{$id};
    }

    sub subcommands { map { /^cmd_(.*)/ ? $1 : () } keys(%rong::) }

    # Result should always end in one line starting with 'OK' or 'ERR'.
    sub invoke {
        my ($id, $line) = @_;
        warn "(client $id sent, path '$opt{$id}{pwd}'): $line\n"; # received input
        eval {
            my ($cmd, @arg) = deserialize($line);
            die "Unrecognized command\n" unless $rong::{"cmd_$cmd"};
            $rong::{"cmd_$cmd"}($id, @arg);
        };
        say !$@ ? 'OK' : do {
            my ($cmd) = $line =~ /(\S+)/;
            chomp(my $msg = $@);
            "ERR Command '$cmd': $msg";
        };
        return not $@;
    }
}

sub server_main {
    my ($listenfh, $listenfile) = @_;
    warn "(server started)\n";
    my $sockets = IO::Select->new($listenfh);  # wait for input on sockets
    while (my @ready = $sockets->can_read) {
        foreach my $fh (@ready) {              #   for each input
            if ($fh == $listenfh) {            #      client connected
                my $clientfh = $listenfh->accept;
                if ($clientfh) {
                    $clientfh->autoflush(1);
                    $sockets->add($clientfh);
                    select($clientfh);
                    rong::initialize(fileno($clientfh), $listenfile);
                }
                next;
            }
            my $fn = fileno($fh);
            defined(my $line = <$fh>) or do {  #      client disconnected
                rong::terminate($fn);
                $sockets->remove($fh);
                $fh->close;
                next;
            };
            chomp $line;
            select($fh);
            rong::invoke($fn, $line);
        }
    }
}

# Send $cmdstring to server $fh, setting $reply to the response gotten from
# server. Returns true if server returned an 'OK' response, false otherwise (in
# which case $reply is set to `undef` and $@ is set to an error message).
sub send_command(\$$$) {
    my ($reply, $fh, $cmdstr) = @_;
    my $sockets = IO::Select->new($fh);

    # Send command.
    if ($sockets->can_write) {
        say $fh $cmdstr;
    }

    # Read server response.
    if ($sockets->can_read) {
        $$reply = eval {
            $fh->recv(my $reply, 1024*1024) // die "Cannot read server response\n";
            chomp($reply);
            $reply =~ s/^(ERR|OK)\b\s*(.*)\z//m;
            my ($status, $msg) = ($1 // '', $2);
            die "$msg\n" if $status eq 'ERR';
            die "Unknown server response: $reply\n" unless $status eq 'OK';
            $reply;
        };
    }
    return not $@;
}

###############################################################################
# Main

local $SIG{__DIE__} = sub {
    die @_ if $^S;                             # abort if called inside eval
    my $program = (File::Spec->splitpath(__FILE__))[2];
    # When not called from function, add extra help.
    die("$program: @_", defined(caller(1))
        ? '' : "Try '$program --help' for more information.\n");
};

my $tempdir = create_tempdir();
my $socket  = File::Spec->join($tempdir, "default");
my $logfile = File::Spec->join($tempdir, "default.log");

my @arg;
while (@ARGV) {
    local $_ = shift(@ARGV);
    /^--$/ and do { push(@arg, @ARGV); last };
    /^(-h|--help)$/ and help();
    /^(-V|--version)$/ and version();
    /^-./ and die "Unrecognized option '$_'\n";
    push(@arg, $_);
}

# Connect to server.
my $server = start_server($socket, $logfile)
    or die("Cannot connect to socket '$socket': $IO::Socket::errstr\n");
my $sockets = IO::Select->new($server);

# Verify server greeting.
my $greeting;
if ($sockets->can_read) {
    defined($greeting = <$server>) or die "Cannot read server greeting: $!\n";
    die "Cannot understand server greeting\n",
        "    expected: OK rong #.#.# $socket\n",
        "    but got : $greeting"
        unless $greeting =~ /^OK rong \d+\.\d+\.\d+ \Q$socket\E$/;
}

send_command(my $result, $server, rong::serialize(
    'cd', Cwd::getcwd() // File::Spec->rootdir()
)) or warn "Cannot change dir: $@";

# Get subcommand from command line.
my $cmd = do {
    my %cmds = map { $_ => 1 } (rong::subcommands(), 'repl');
    @arg == 0           ? 'list' :             # no args
        !$cmds{$arg[0]} ? 'load'               # only filenames given
                        : shift(@arg);         # 1st arg is subcommand
};

# Repeat command for each arg (but send one command if no args).
if ($cmd ne 'repl') {
    my $err;
    for my $arg (@arg ? @arg : undef) {
        my $cmdstr = rong::serialize($cmd, $arg // ());
        if (send_command(my $result, $server, $cmdstr)) {
            print $result;
        } else {
            my $program = (File::Spec->splitpath(__FILE__))[2];
            warn "$program: $@";
            $err = 1;
        }
    }
    exit($err ? 127 : 0);
}

# Client: Wait until there's input from either STDIN or $server.
die "Too many arguments\n" if @arg;
print $greeting;
$sockets->add(\*STDIN);
while (my @ready = $sockets->can_read) {
    foreach my $fh (@ready) {
        if ($fh == $server) {                  # from server -> write to STDOUT
            $fh->recv(my $x, 1024*1024) // die "Cannot read server response\n";
            chomp($x);
            say $x;
        } else {                               # from STDIN -> write to server
            defined(my $x = <$fh>) or exit;    # ^D from STDIN = exit
            chomp($x);
            if (send_command(my $result, $server, $x)) {
                print $result;
                say "OK";
            } else {
                print "ERR $@";
            }
        }
    }
}

#[eof]
