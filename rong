#!/usr/bin/env perl
# Copyright (C) 2023-2024 zrajm <rong@zrajm.org>
# License: GPLv2 [https://gnu.org/licenses/gpl-2.0.txt]

# https://perl.com/pub/2012/04/perlunicook-standard-preamble.html
use utf8;      # so literals and identifiers can be in UTF-8
use v5.12;     # or later to get "unicode_strings" feature
use strict;    # quote strings, declare variables
use warnings;  # on by default
use warnings  qw(FATAL utf8);    # fatalize encoding glitches
use open      qw(:std :utf8);    # undeclared streams in UTF-8
use charnames qw(:full :short);  # unneeded in v5.16

use IO::Socket;
use IO::Select;
use POSIX;

our $AUTHOR='zrajm <rong@zrajm.org>';
our $VERSION='0.0.14';                         # https://semver.org/
our $VERSION_DATE='10 January 2024';
our $CREATED_DATE='28 December 2023'; # never change this!
our $USAGE = <<'USAGE_END';
Usage: rong [OPTION]... [FILE]...
A daemonic headless editor.

Options:
  -h, --help      Display this help and exit
  -V, --version   Output version information and exit
USAGE_END

###############################################################################
# Functions

sub help { print $USAGE; exit 0; }
sub version {
    (my $file     = __FILE__     ) =~ s#^.*/##;
    (my $years    = $CREATED_DATE) =~ s#^.* ##;
    (my $end_year = $VERSION_DATE) =~ s#^.* ##;
    if ($years ne $end_year) { $years .= "-$end_year" }
    print(
        "$file (zrajm utils) $VERSION ($VERSION_DATE)\n",
        "Copyright (C) $years $AUTHOR\n",
        "License: GNU GPLv2 <https://gnu.org/licenses/gpl-2.0.txt>.\n",
        "This is free software: You are free to change and redistribute it.\n");
    exit 0;
}

# Usage: create_tempdir()
#
# Creates a run directory for the Rong server and clients. The directory is
# called '<TEMPDIR>/<PROGRAMNAME>-<USERID>' (usually '/tmp/rong-1000' but all
# parts can change depending on your $TEMPDIR variable, the name of the script
# and your user's numerical user id). The directory name is the same as Tmux.
sub create_tempdir {
    my $dir = sprintf '%s/%s-%s',
        ($ENV{TMPDIR} // '/tmp'),              # tempdir
        (split('/', $0))[-1],                  # program's basename
        $<;                                    # real user ID (number)
    mkdir($dir, 0700) or die "Cannot create tempdir '$dir': $!\n"
        unless -d $dir;
    return $dir;
}

# Used by client to connect to server.
sub connection_socket {
    my ($socket_path) = @_;
    my $fh = IO::Socket::UNIX->new(
        Type => SOCK_STREAM(),
        Peer => $socket_path,
    );
    $fh->autoflush(1) if $fh;
    return $fh;
}

# Used by server to listen for new client connections.
sub listening_socket {
    my ($socket_path) = @_;
    if (-e $socket_path) {
        -S $socket_path
            or die "Will not delete non-socket file '$socket_path'\n";
        unlink $socket_path
            or die "Cannot delete previous socket '$socket_path': $!\n";
    }
    my $fh = IO::Socket::UNIX->new(
        Listen => 1,
        Type => SOCK_STREAM(),
        Local => $socket_path,
    );
    $fh->autoflush(1) if $fh;
    return $fh;
}

sub start_server {
    my ($socket_path, $logfile) = @_;

    # If server is already running, return connection to that.
    if (my $clientfh = connection_socket($socket_path)) {
        return $clientfh;
    }

    # Create server's listening socket to which new clients connect (it's
    # inherited by child processes). Done BEFORE forking avoid race condition
    # where child tries to connect and listening socket isn't yet there.
    my $listenfh = listening_socket($socket_path)
        or die("Cannot create socket '$socket_path': $IO::Socket::errstr\n");

    # Start intermediate process (session leader in new session).
    defined(my $inter_pid = fork) or die "Cannot fork intermediate: $!\n";
    if ($inter_pid == 0) {                     # in intermediate
        (POSIX::setsid != -1) or die "Cannot start new session: $!";
        # Start server process.
        defined(my $server_pid = fork) or die "Cannot fork server: $!\n";
        if ($server_pid == 0) {                # in server
            $0 .= ' --daemon';                 #   server process name
            umask(0) or die "Cannot change umask to '0': $!\n";
            chdir('/') or die "Cannot change directory to '/': $!\n";
            open(STDOUT, '>>', $logfile)
                or die "Cannot open logfile '$logfile': $!\n";
            open(STDERR, '>&', STDOUT)
                or die "Cannot redirect STDERR to logfile '$logfile': $!\n";
            close STDIN;
            server_main($listenfh, $socket_path);# never returns
            exit 0;
        }
        exit 0;
    }

    # Client process (original process).
    close $listenfh;                           # close listening socket
    wait;                                      # reap intermediate process
    return connection_socket($socket_path)     # connect to new server
}

sub server_main {
    my ($listenfh, $listenfile) = @_;
    my $sockets = IO::Select->new($listenfh);  # wait for input on sockets
    while (my @ready = $sockets->can_read) {
        foreach my $fh (@ready) {              #   for each input
            if ($fh == $listenfh) {            #      client connected
                my $clientfh = $listenfh->accept;
                if ($clientfh) {
                    $clientfh->autoflush(1);
                    $sockets->add($clientfh);
                    my $fn = fileno($clientfh);
                    my ($program) = __FILE__ =~ m#([^/]*$)#;
                    print "(client $fn connected)\n";
                    print $clientfh "OK $program $VERSION $listenfile\n";
                }
                next;
            }
            my $fn = fileno($fh);
            defined(my $line = <$fh>) or do {  #      client disconnected
                print "(client $fn disconnected)\n";
                $sockets->remove($fh);
                $fh->close;
                next;
            };
            chomp $line;
            print "(client $fn sent): $line\n";# received input
            print $fh "OK ($line)\n";
        }
    }
}

###############################################################################
# Main

my $tempdir = create_tempdir();
my $socket = "$tempdir/default";
my $logfile = "$socket.log";

$SIG{__DIE__} = sub {
    my ($name) = $0 =~ m#([^/]*$)#;
    # When not called from function, add extra help.
    die("$name: @_", defined(caller(1))
        ? '' : "Try '$name --help' for more information.\n");
};

my @arg;
while (@ARGV) {
    local $_ = shift(@ARGV);
    /^--$/ and do { push(@arg, @ARGV); last };
    /^(-h|--help)$/ and help();
    /^(-V|--version)$/ and version();
    /^-./ and die "Unrecognized option '$_'\n";
    push(@arg, $_);
}

# Connect to server.
my $server = start_server($socket, $logfile)
    or die("Cannot connect to socket '$socket': $IO::Socket::errstr\n");
my $sockets = IO::Select->new($server);

# Verify server greeting.
my $greeting;
if ($sockets->can_read) {
    defined($greeting = <$server>) or die "Cannot read server greeting: $!\n";
    die "Cannot understand server greeting\n",
        "    expected: OK rong #.#.# $socket\n",
        "    but got : $greeting"
        unless $greeting =~ /^OK rong \d+\.\d+\.\d+ \Q$socket\E$/;
}

# Send command(s) to server.
if (@arg) {
    my $cwd = POSIX::getcwd();
    for my $arg (@arg) {
        if ($sockets->can_write) {
            print $server "load '$cwd/$arg'\n";
        }
        if ($sockets->can_read) {
            defined(my $reply = <$server>)
                or die "Server terminated connection: $!\n";
            print $reply;
        }
    }
    exit 0;
}

# Client: Wait until there's input from either STDIN or $server.
print $greeting;
$sockets->add(\*STDIN);
while (my @ready = $sockets->can_read) {
    foreach my $fh (@ready) {
        defined(my $x = <$fh>) or exit;        # ^D from STDIN = exit
        if ($fh == $server) {                  # from server -> write to STDOUT
            print $x;
        } else {                               # from STDIN -> write to server
            print $server $x;
        }
    }
}

#[eof]
